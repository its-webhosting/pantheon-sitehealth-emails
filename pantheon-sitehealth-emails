#!/usr/bin/env python
#
# pantheon-sitehealth-emails
#
# Send emails to website owners letting them know what their Pantheon traffic has been and make recommendations about
# whether/how they should change their current plan or the configuration of their site.
#
# Usage:
#   pantheon-sitehealth-emails [-h|--help] 
#

import argparse
import importlib
import tomllib
import os
import stat
import sys
import time
import json
import subprocess
import datetime
import calendar
import ipaddress
import html
import io
import re
import copy
import shlex
import glob
from smtplib import SMTP_SSL
from typing import Any

import urllib.parse

from email.message import EmailMessage
from email.utils import make_msgid
from email.policy import SMTP

import dns.resolver

import sqlalchemy as db
from sqlalchemy import insert
from sqlalchemy import Integer, String, Date, Boolean
from sqlalchemy import PrimaryKeyConstraint, UniqueConstraint
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy.types import CHAR
from sqlalchemy.dialects.sqlite import insert as sqlite_insert

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import matplotlib.patheffects as path_effects
from matplotlib.gridspec import GridSpec
from matplotlib.patches import Polygon
import numpy as np

from jinja2 import Template

from rich.padding import Padding
from rich.pretty import pprint

import script_context as sc


traffic_table_columns = [
    {'name': 'month', 'label': 'Month'},
    {'name': 'visitors', 'label': 'Pantheon Visitors'},
    {'name': 'plan', 'label': 'Plan'},
    {'name': 'plan-limit', 'label': 'Plan Limit'},
    {'name': 'overage', 'label': 'Overage'},
    {'name': 'overage-blocks', 'label': 'Overage Blocks'},
    {'name': 'overage-cost', 'label': 'Overage Cost'},
    {'name': 'overage-protection', 'label': 'Overage Protection'},
    {'name': 'upgrade-at', 'label': 'Upgrade At'},
    {'name': 'next-plan', 'label': 'Upgrade To'},
    {'name': 'downgrade-at', 'label': 'Downgrade At'},
    {'name': 'previous-plan', 'label': 'Downgrade To'},
]

cost_table_columns = [
    {'name': 'plan', 'label': 'Plan'},
    {'name': 'cost-same', 'label': 'Same Traffic Cost'},
    {'name': 'cost-median', 'label': 'Median Traffic Cost'},
    {'name': 'notes', 'label': ''},
]

fqdn_re = re.compile(r'^_?[a-z0-9-]+\.[a-z0-9.-]+$', re.IGNORECASE)


class Base(DeclarativeBase):
    pass


class PantheonTraffic(Base):
    __tablename__ = 'pantheon_traffic'

    # id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    site_id: Mapped[str] = mapped_column(CHAR(36))
    traffic_date: Mapped[datetime.date] = mapped_column(Date)
    site_plan: Mapped[str] = mapped_column(String(64))
    visits: Mapped[int] = mapped_column(Integer)
    pages_served: Mapped[int] = mapped_column(Integer)
    cache_hits: Mapped[int] = mapped_column(Integer)

    __table_args__ = (
        PrimaryKeyConstraint('site_id', 'traffic_date', name='pk_site_id_traffic_date'),
        UniqueConstraint('site_id', 'traffic_date', name='uix_site_id_traffic_date'),
    )

    def __repr__(self):
        return (f'<{self.site_id} {self.traffic_date} : {self.site_plan} visits={self.visits} '
                f'pages={self.pages_served} cache_hits={self.cache_hits}>')


class PantheonOverageProtection(Base):
    __tablename__ = 'pantheon_overage_protection'

    site_id: Mapped[str] = mapped_column(CHAR(36))
    month: Mapped[datetime.date] = mapped_column(Date)
    months_remaining: Mapped[int] = mapped_column(Integer)
    used_this_month: Mapped[bool] = mapped_column(Boolean)

    __table_args__ = (
        PrimaryKeyConstraint('site_id', 'month', name='pk_op_site_id_traffic_date'),
        UniqueConstraint('site_id', 'month', name='uix_op_site_id_traffic_date'),
    )

    def __repr__(self):
        return f'<{self.site_id} {self.month} : {self.months_remaining}>'


#
# Global initialization:
#

# Parse command line arguments.  This is outside main() so the arguments are available to all functions.
args_parser = argparse.ArgumentParser(
    description='Send emails to website owners letting them know what their Pantheon traffic has been'
                'and make recommendations about whether/how they should change their current plan or'
                'the configuration of their site.'
)
args_parser.add_argument(
    'sites',
    metavar='SITE',
    nargs='*',
    help='a list of site names to process; if not specified, all sites in the Pantheon organization will be processed'
)
args_parser.add_argument(
    '--all', '-a',
    action='store_true',
    default=False,
    help='process all sites in the Pantheon organization'
)
args_parser.add_argument(
    '--date', '-d',
    type=datetime.date.fromisoformat,
    default=datetime.date.today(),
    help='generate the report as if it were this date (YYYYMMDD or YYYY-MM-DD); defaults to today'
)
args_parser.add_argument(
    '--update',
    action='store_true',
    default=False,
    help='just update the site visitors in the database, skipping the reports'
)
args_parser.add_argument(
    '--for-real',
    action='store_true',
    default=False,
    help='send email to the site owners; without this option, the emails will go to the logged-in user instead'
)
args_parser.add_argument(
    '--config', '-c',
    action='store',
    default='pantheon-sitehealth-emails.toml',
    help='TOML configuration file, see pantheon-sitehealth-emails.toml.sample'
)
args_parser.add_argument(
    '--only-warn',
    action='store_true',
    default=False,
    help='only check sites for warnings, do not generate reports or send emails'
)
args_parser.add_argument(
    '--smtp-username', '-u',
    action='store',
    default=os.environ.get('USER', ''),
    help='username for logging into the SMTP server to send mail'
)
args_parser.add_argument(
    '--create-tables',
    action='store_true',
    default=False,
    help='create the database tables and then stop, ignoring all other command line options'
)
args_parser.add_argument(
    '--import-older-metrics',
    action='store_true',
    default=False,
    help='load weekly and monthly Pantheon metrics into the database and then stop, '
         'ignoring all other command line options'
)
args_parser.add_argument(
    '--verbose', '-v',
    action='count',
    default=0,
    help='include extra information in the output'
)
sc.options = args_parser.parse_args()


def escape_url(url):
    return urllib.parse.quote(url, safe=':/?#&=', encoding='utf-8', errors='strict')


def run_terminus(command: list) -> (str, str, bool):

    command = ['terminus', '--no-ansi', '--no-interaction', *command]
    commandline = ' '.join([(("'" + arg.replace("'", "\\'") + "'") if len(arg.split()) > 1 else arg) for arg in command])

    sc.debug('Running Terminus command:\n', commandline)

    with sc.console.status(f'[bold green]Running: [bright_magenta]{commandline}'):
        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
        try:
            stdout, stderr = p.communicate(timeout=300)
        except subprocess.TimeoutExpired:
            p.kill()
            stdout, stderr = p.communicate()
            output = stdout.decode('utf-8').strip()
            errors = stderr.decode('utf-8').strip()
            sc.console.print('[bold red]Terminus command timed out.')
            sc.console.print('===== stdout:\n' + output)
            sc.console.print('===== stderr:\n' + errors)
            errors += '\n[ERROR] Terminus command timed out.\n'
            return output, errors, True

    output = stdout.decode('utf-8').strip()
    errors = stderr.decode('utf-8').strip()

    if command[3] in ('wp', 'composer') and len(output) > 0 and (p.returncode == 0 or command[3] == 'composer'):
        lines = output.split('\n')
        filtered_lines = []
        extra_errors = []
        for line in lines:
            if re.match(r'^\s*Cannot create cache directory\s+', line):
                continue
            if re.match(r'^\s*Warning:\s+', line):
                extra_errors.append(line)
            else:
                filtered_lines.append(line)
        output = '\n'.join(filtered_lines)
        if command[3] == 'composer':
            errors = ''
            p.returncode = 0
        else:
            errors = '\n'.join(extra_errors) + '\n' + errors
    sc.debug('Terminus output:\n', output, level=3)

    if len(errors) > 0 and p.returncode == 0:
            lines = errors.split('\n')
            filtered_lines = []
            for line in lines:
                line = line.strip()
                if line != '' \
                    and not line.endswith('[Exit: 0] (Attempt 1/1)') \
                    and not line.startswith('[warning] There are no available updates') \
                    and not (line.startswith("Warning: Permanently added") and line.endswith('to the list of known hosts.')):
                        filtered_lines.append(line)
            errors = '\n'.join(filtered_lines)
    if len(errors) > 0:
        sc.console.print('Terminus errors:')
        sc.console.print(errors)

    if p.returncode != 0:
        line = f"Terminus command failed with exit code {p.returncode}: {stderr}\n"
        sc.console.print(f'[bold red][ERROR] {line}')
        errors += "\n" + line
        return output, errors, True

    return output, errors, False


def terminus(*args) -> Any:
    """
    Run Terminus with the given arguments and return the result as a JSON object.
    """
    command = [*args, '--format=json']
    output, errors, fatal = run_terminus(command)
    try:
        result = json.loads(output)
    except json.JSONDecodeError as e:
        result = ''  # TODO: set to None
        errors += "\n" + output + "\n" + str(e)
    if errors != '':
        sc.console.print(f'[bold red]Terminus error: {errors}')
    #return result, errors.strip(), fatal  # TODO
    return result


def wp(siteenv: str, *args) -> (Any, str):
    """
    Run a "wp eval" command through Terminus and return the result as JSON.
    """
    command = ['wp', siteenv, '--', *args, '--format=json']
    output, errors, fatal = run_terminus(command)
    try:
        result = json.loads(output)
    except json.JSONDecodeError as e:
        result = None
        errors += "\n" + output + "\n" + str(e)
    return result, errors.strip(), fatal


def wp_eval(siteenv: str, *args) -> (str, str):
    """
    Run a "wp eval" command through Terminus and return the result as a string.
    """
    command = ['wp', siteenv, '--', 'eval', *args]
    output, errors, fatal = run_terminus(command)
    return output.strip(), errors.strip(), fatal


def wp_error(site: str, code: str, message: str, errors: str) -> list[dict]:
    html_message = message.replace(site, f'<strong>{site}</strong>')
    return [{
        'type': 'alert',
        'icon': '&#x1F6A8;',  # police car light
        'csv': f'{site},wp-error,{code},{json.dumps(errors).replace(',', '\\,')}',
        'short': f'fix WP CLI error',
        'message': f'''
<p>{html_message}
<code>wp</code> (WP CLI) returned the following error:</p>
<pre>{html.escape(errors)}</pre>
''',
        'text': f'''
{message}
"wp" (WP CLI) returned the following error:

----- START WP CLI ERROR -----
{errors}
----- END WP CLI ERROR -----

''',
    }]


def fix_drush_output(output: str, errors: str) -> (str, str):
    """
    Move any error messages at the start of the output from a Drush command to the errors string.
    """
    if not isinstance(output, str) or output == '':
        return output, errors

    if output[0] != '{':
        lines = output.split('\n')
        linenum = 0
        while linenum < len(lines):
            if lines[linenum][0] == '{':
                break
            linenum += 1
        errors = '\n'.join(lines[:linenum]) + errors
        output = '\n'.join(lines[linenum:])

    sc.debug('Drush output:\n', output, '\nDrush errors:\n', errors, level=2)

    return output, errors


def drush(siteenv: str, *args) -> (Any, str):
    """
    Run a "drush" command through Terminus and return the result as a JSON object.
    """
    command = ['drush', siteenv, '--', *args, '--format=json']
    output, errors, fatal = run_terminus(command)
    output, errors = fix_drush_output(output, errors)
    try:
        result = json.loads(output)
    except json.JSONDecodeError as e:
        result = None
        errors += "\n" + output + "\n" + str(e)
    return result, errors.strip(), fatal


def drush_php_eval(siteenv: str, *args) -> (Any, str):
    """
    Run a "drush php:eval" command through Terminus and return the result as a string.
    """
    command = ['drush', siteenv, '--', 'php:eval', *args, '--format=json']
    output, errors, fatal = run_terminus(command)
    output, errors = fix_drush_output(output, errors)
    try:
        result = json.loads(output)
    except json.JSONDecodeError as e:
        result = None
        errors += "\n" + output + "\n" + str(e)
    return result, errors.strip(), fatal


def drush_error(site: str, code: str, message: str, errors: str) -> list[dict]:
    html_message = message.replace(site, f'<strong>{site}</strong>')
    return [{
        'type': 'alert',
        'icon': '&#x1F6A8;',  # police car light
        'csv': f'{site},drush-error,{code},{json.dumps(errors).replace(',', '\\,')}',
        'short': f'fix drush error',
        'message': f'''
<p>{html_message}
<code>drush</code> returned the following error:</p>
<pre>{html.escape(errors)}</pre>
''',
        'text': f'''
{message}
drush returned the following error:

----- START DRUSH ERROR -----
{errors}
----- END ERROR -----

''',
    }]


def get_old_metrics(site_env: str, site: dict, period: str, end_date: datetime.date) -> list:
    sc.console.print(f'[bold magenta]=== Processing old data by {period}:')
    metrics = terminus('env:metrics', site_env, f'--period={period}')
    new_rows = []

    for e in metrics['timeseries']:

        entry = metrics['timeseries'][e]
        if entry['visits'] == 0 and entry['pages_served'] == 0:
            sc.debug(f'No traffic for {period} {entry["datetime"]}')
            continue

        traffic_date = datetime.datetime.strptime(entry['datetime'], '%Y-%m-%dT%H:%M:%S').date()
        if period == 'week':
            days_in_period = 7
        else:
            _, days_in_period = calendar.monthrange(traffic_date.year, traffic_date.month)

        visits_per_day = entry['visits'] // days_in_period
        visits_last_day = visits_per_day + entry['visits'] % days_in_period
        pages_served_per_day = entry['pages_served'] // days_in_period
        pages_served_last_day = pages_served_per_day + entry['pages_served'] % days_in_period
        cache_hits_per_day = entry['cache_hits'] // days_in_period
        cache_hits_last_day = cache_hits_per_day + entry['cache_hits'] % days_in_period

        sc.debug(f'traffic/day for {period} starting {traffic_date}: visits={visits_per_day} '
                 f'pages={pages_served_per_day} cache_hits={cache_hits_per_day}', level=2)

        for i in range(days_in_period):
            if traffic_date < end_date:
                if i < days_in_period - 1:
                    daily_traffic = {'site_id': site['id'], 'traffic_date': traffic_date,
                                     'site_plan': site['plan_name'],
                                     'visits': visits_per_day, 'pages_served': pages_served_per_day,
                                     'cache_hits': cache_hits_per_day}
                else:
                    daily_traffic = {'site_id': site['id'], 'traffic_date': traffic_date,
                                     'site_plan': site['plan_name'],
                                     'visits': visits_last_day, 'pages_served': pages_served_last_day,
                                     'cache_hits': cache_hits_last_day}
                new_rows.append(daily_traffic)
            traffic_date += datetime.timedelta(days=1)

    return new_rows


def check_wordpress_plugin(site: str, installed_plugins: list, name: str, display_name: str, url: str, reason: str) -> list:
    notices = []
    if not isinstance(installed_plugins, list):
        return notices  # this error should already have been handled by our caller, so skip additional work

    installed = [p for p in installed_plugins if p['name'] == name]

    if len(installed) == 0:
        sc.console.print(f':exclamation: [bold red] ATTENTION: {site} does not have the {display_name} plugin installed.')
        notices.append({
            'type': 'warning',
            'icon': '&#x26A0;',  # warning sign
            'csv': f'{site},not-installed,{name}',
            'short': f'install the {name} plugin',
            'message': f'<p>The <a href="{escape_url(url)}">{html.escape(display_name)}</a> WordPress plugin needs to be installed:</p><p>{html.escape(reason)}</p>',
            'text': f"The {display_name} WordPress plugin\n<{url}>\nneeds to be installed: {reason}",
        })
        return notices

    if len(installed) > 1:
        sc.console.print(f':exclamation: [bold red] ATTENTION: {site} has more than one {display_name} plugin installed.')
        notices.append({
            'type': 'info',
            'icon': '&#x1F50E;',  # magnifying glass
            'csv': f'{site},multiple-installed,{name}',
            'short': f'plugin {name} installed multiple times',
            'message': f'<p>The <a href="{escape_url(url)}">{html.escape(display_name)}</a> WordPress plugin is installed multiple times.</p>',
            'text': f"The {display_name} WordPress plugin\n<{url}>\nis installed multiple times.",
        })

    plugin = installed[0]
    if not 'status' in plugin or plugin['status'] not in ('active', 'must-use'):
        sc.console.print(f':exclamation: [bold red] ATTENTION: {site} has the {display_name} plugin installed but it is not active.')
        notices.append({
            'type': 'warning',
            'icon': '&#x26A0;',  # warning sign
            'csv': f'{site},turned-off,{name}',
            'short': f'activate plugin {name}',
            'message': f'<p>The <a href="{escape_url(url)}">{html.escape(display_name)}</a> WordPress plugin needs to be activated:</p><p>{html.escape(reason)}</p>',
            'text': f"The {display_name} WordPress plugin\n<{url}>\nneeds to be activated: {reason}",
        })

    return notices


def check_drupal_module(site: str, installed_mods: dict, name: str, display_name: str, url: str, reason: str) -> list:
    notices = []
    if not isinstance(installed_mods, dict):
        return notices  # this error should already have been handled by our caller, so skip additional work

    if not name in installed_mods:
        sc.console.print(f':exclamation: [bold red] ATTENTION: {site} does not have the {display_name} module installed.')
        notices.append({
            'type': 'warning',
            'icon': '&#x26A0;',  # warning sign
            'csv': f'{site},not-installed,{name}',
            'short': f'install module {name}',
            'message': f'<p>The <a href="{escape_url(url)}">{html.escape(display_name)}</a> Drupal module needs to be installed:</p><p>{html.escape(reason)}</p>',
            'text': f"The {display_name} Drupal module\n<{url}>\nneeds to be installed: {reason}",
        })
        return notices

    mod = installed_mods[name]
    if not 'status' in mod or mod['status'] != 'Enabled':
        sc.console.print(f':exclamation: [bold red] ATTENTION: {site} has the {display_name} module installed but it is not enabled.')
        notices.append({
            'type': 'warning',
            'icon': '&#x26A0;',  # warning sign
            'csv': f'{site},turned-off,{name}',
            'short': f'enable module {name}',
            'message': f'<p>The <a href="{escape_url(url)}">{html.escape(display_name)}</a> Drupal module needs to be enabled:</p><p>{html.escape(reason)}</p>',
            'text': f"The {display_name} Drupal module\n<{url}>\nneeds to be enabled: {reason}",
        })

    return notices


def config_substitution(expr: str, path) -> str:
    argv = list(shlex.shlex(expr, posix=True))
    argc = len(argv)
    if sc.options.verbose > 1:
        sc.debug(f'\nconfig_substitution: {path}')
        pprint(argv)
    if argc == 0:
        return ''

    # Figure out which substitution matches the expression most closely:
    best_match = None
    best_match_score = 0
    best_match_args_map = {}
    for match in sc.substitutions:
        match_args = match['args']
        match_args_len = len(match_args)
        match_score = 0
        args_map = {}
        for i in range(argc):
            if i >= match_args_len:
                break
            if match_args[i] == argv[i]:
                match_score += 1
            elif match_args[i].startswith('$'):
                match_score += 1
                args_map[match_args[i]] = argv[i]
            else:
                break
        if match_score > best_match_score:
            best_match = match
            best_match_score = match_score
            best_match_args_map = args_map
            if match_score == argc and match_score == match_args_len:
                break

    if sc.options.verbose >= 2:
        sc.debug(f'best_match: {best_match_score}')
        pprint(best_match_args_map)
        pprint(best_match)

    if best_match_score == argc:
        func_args = [best_match_args_map[arg] for arg in best_match['func_args']]
        if sc.options.verbose >=2:
            sc.debug('args:')
            pprint(func_args)
        result = best_match['func'](*func_args)
        if result is None:
            sys.exit(1)
        return str(result)

    if best_match_score == 0:
        sc.console.print(f'[bold red]ERROR: configuration file value for {path} contains an unknown substitution: {expr}')
        sys.exit(1)

    sc.console.print(f'[bold red]ERROR: no match found for configuration file value of {path}')
    sc.console.print(f'[bold red]value: {argv}')
    sc.console.print(f'[bold red]best match: {best_match["args"]}')
    sc.console.print(f'[bold red]{best_match_score} out of {argc} arguments matched')
    sys.exit(1)


config_substitution_re = re.compile(r'<\{(.*?)(?<!\\)}')

def process_config(data: Any, path="") -> Any:
    if isinstance(data, dict):
        for key, value in data.items():
            new_path = f"{path}.{key}" if path else f"{key}"
            data[key] = process_config(value, new_path)
    elif isinstance(data, list):
        for index, item in enumerate(data):
            new_path = f"{path}[{index}]"
            data[index] = process_config(item, new_path)
    elif isinstance(data, str):
        data = re.sub(config_substitution_re, lambda m: config_substitution(m.group(1), path), data)
    return data


def find_modules(module_type: str) -> list[str]:
    modules = []
    # find all non-empty regular files in/under the directory f"{type}" that are named "__init__.py":
    for dirpath, dirs, files in os.walk(module_type, followlinks=True):
        for file in files:
            if file == '__init__.py':
                target = os.path.join(dirpath, file)
                st = os.stat(target)
                if stat.S_ISREG(st.st_mode) and st.st_size != 0:
                    parts = target.split('/')[:-1]
                    target_name = '.'.join(parts)
                    modules.append(target_name)
    modules.sort()  # ensure a consistent order when importing to simplify troubleshooting
    return modules


def smtp_login() -> SMTP_SSL:
    # TODO: get password from config file, from secret or prompt for it
    smtp_connection = SMTP_SSL('smtp.mail.umich.edu', port=465)
    smtp_connection.login(sc.options.smtp_username, os.environ['SMTP_PASSWORD'])
    return smtp_connection


def main() -> None:

    sc.debug(f'Loading configuration from {sc.options.config}')
    with open(sc.options.config, 'rb') as f:
        sc.config = tomllib.load(f)

    sc.debug(f'[bold magenta]=== Loading plugins:')
    for plugin_name in find_modules('plugin'):
        sc.debug(f'Loading plugin: {plugin_name}')
        module = importlib.import_module(plugin_name)
        sc.plugin[plugin_name] = module

    sc.debug(f'Doing pre-setup configuration substitutions')
    sc.config = process_config(sc.config)

    sc.debug(f'[bold magenta]=== Loading checks:')
    for check_name in find_modules('check'):
        sc.debug(f'Loading check: {check_name}')
        module = importlib.import_module(check_name)
        sc.check[check_name] = module

    # Validate and process arguments
    if sc.options.create_tables:
        if sc.options.import_older_metrics:
            sys.exit('The --import-older-metrics and --create-tables options are mutually exclusive.')
        sc.options.verbose = 3  # force verbose output
    elif (sc.options.all and len(sc.options.sites) != 0) or (not sc.options.all and len(sc.options.sites) == 0):
        sys.exit('You must specify either at least one site or the --all option.')
    if sc.options.verbose:
        sc.debug('Arguments:')
        pprint(sc.options)
        pprint(terminus('self:info'))

    # Create a directory named "build" if it doesn't exist:
    if not os.path.exists('build'):
        os.makedirs('build')

    sc.invoke_hooks('setup')

    sc.debug(f'Doing post-setup configuration substitutions')
    sc.config = process_config(sc.config)
    if sc.options.verbose:
        sc.debug('Configuration after substitutions:')
        pprint(sc.config)

    overage_block_size = sc.config['Pantheon']['overage_block_size']
    overage_block_cost = sc.config['Pantheon']['overage_block_cost']

    sc.debug('[bold magenta]=== Connecting to the [green]pantheon-sitehealth-emails[/green] traffic database:')

    if sc.config['Database']['type'] == 'sqlite':
        traffic_db_conn_str = f'sqlite:///{sc.config["Database"]["name"]}'
        traffic_db_conn_kwargs = {}
    elif sc.config['Database']['type'] == 'mysql':
        traffic_db_conn_str = f'mysql+mysqldb://{sc.config["Database"]["user"]}:{sc.config["Database"]["password"]}@' \
                             f'{sc.config["Database"]["host"]}:{sc.config["Database"]["port"]}/{sc.config["Database"]["name"]}'
        traffic_db_conn_kwargs = { 'pool_size': 10, 'max_overflow': 20 }
    else:
        sys.exit(f'Unsupported database type: {sc.config["Database"]["type"]}')

    db_engine = db.create_engine(traffic_db_conn_str,
                                 echo=True if sc.options.verbose >= 2 else False,
                                 **traffic_db_conn_kwargs)
    db_session_factory = db.orm.sessionmaker(bind=db_engine)
    db_session = db_session_factory()

    if sc.options.create_tables:
        Base.metadata.create_all(db_engine)
        sys.exit('Tables created.')

    with open("header-image.png", 'rb') as img:
        wordmark_image = img.read()

    if sc.options.smtp_username == '':
        sys.exit("--smtp-username not specified and USER environment variable not set.")
    smtp_connection = smtp_login()

    if 'News' in sc.config:
        for news_item_name in sc.config['News'].keys():
            if not isinstance(news_item_name, dict):
                continue  # skip News configuration directives
            sc.add_news_item(
                sc.config['News'][news_item_name],
                f'{news_item_name} in configuration file {sc.options.config}'
            )
    for filename in sorted(glob.glob(f'{sc.config["News"]["folder"]}/*.toml')):
        with open(filename, 'rb') as f:
            n = tomllib.load(f)
            if 'News' not in n:
                sys.exit(f'News item in {filename} is missing the "News" key.')
            for news_item_name in n['News'].keys():
                sc.add_news_item(
                    n['News'][news_item_name],
                    f'{news_item_name} in file {filename}'
                )
    if sc.options.verbose:
        sc.debug('[bold magenta]=== News:')
        pprint(sc.news)

    for plan in sc.config['Pantheon']['plan_info']:
        upgrade_to = sc.config['Pantheon']['plan_info'][plan]['upgrade_to']
        downgrade_to = sc.config['Pantheon']['plan_info'][plan]['downgrade_to']
        sc.config['Pantheon']['plan_info'][plan]['upgrade_to'] = upgrade_to if upgrade_to != '-' else None
        sc.config['Pantheon']['plan_info'][plan]['downgrade_to'] = downgrade_to if downgrade_to != '-' else None
    plan_info = sc.config['Pantheon']['plan_info']  # create an alias for convenience and readability
    plan_names = list(plan_info.keys())

    end_date = sc.options.date
    end_date_yyyy_mm = end_date.strftime('%Y-%m')
    start_date = end_date.replace(day=1, year=end_date.year - 1)  # fist day of the same month last year
    end_of_contract_year = True if end_date.month == 6 and 16 < end_date.day < 30 else False
    sc.debug(f'Generating report for {start_date} through {end_date}')

    # Generate a cap shape to use at the end of the traffic surge chart bars
    cap_size = 2 * np.pi
    x = np.linspace(0, cap_size, 31)
    y = (np.sin(x - np.pi / 2) + 1) / 2
    cap_points = np.array(list(zip(x, y)))
    cap_points_inv = np.concatenate(([[0, 0]], cap_points - [0, 1], [[cap_size, 0]]), axis=0)
    cap_points = np.concatenate(([[0, 0]], cap_points, [[cap_size, 0]]), axis=0)

    sites = terminus('org:site:list', sc.config['Pantheon']['org_id'])
    site_count = len(sites)
    current_site_number = 1
    emails_sent = 0
    site_savings = []
    all_warnings = []
    site_results = {}
    cloudflare_enabled = 'plugin.cloudflare' in sc.plugin
    sc.debug('Cloudflare is ' + ('[bold green]enabled' if cloudflare_enabled else '[bold red]DISABLED'))

    for site_id in sites:
        site = sites[site_id]
        its_downgrade_site = False
        site_notices = []
        wp_smell = ''
        drush_smell = ''
        composer_smell = ''
        portal_site_id = 0
        if 'UMich' in sc.config and 'enabled' in sc.config['UMich'] and sc.config['UMich']['enabled']:
            if site['name'] not in sc.config['UMich']['portal']['sites']:
                sc.console.print(f':exclamation: [bold red] ATTENTION: {site["name"]} is not in the WWS portal!')
                continue
            portal_site_id = sc.config['UMich']['portal']['sites'][site['name']]['id']

        if not sc.options.all and site['name'] not in sc.options.sites:
            sc.debug(f'[bold magenta]=== Skipping site {site["name"]} (not in list of sites to process)', level=2)
            continue
        sc.console.print('\n',
                      Padding(f'Pantheon site {current_site_number} of {site_count}: [bold]{site["name"]}[/bold]',
                              1, style='white on blue'),
                      '\n'
                      )
        current_site_number += 1

        if site['plan_name'] == 'Elite':
            # Pantheon uses the same display name (but a different SKU) for each Elite plan.
            site_plan_info = terminus('plan:info', site['name'])
            if 'sku' not in site_plan_info:
                sc.console.print(f':exclamation: [bold red] ERROR: {site["name"]} doesn\'t have a plan SKU')
                sys.exit('Bailing out.')
            plan_sku = site_plan_info['sku']
            if plan_sku not in sc.config['Pantheon']['plan_sku_to_name']:
                sc.console.print(f':exclamation: [bold red] ERROR: {site["name"]} has an unknown plan SKU: {plan_sku}')
                sys.exit('Bailing out.')
            site['plan_name'] = sc.config['Pantheon']['plan_sku_to_name'][plan_sku]
        site_current_plan = site['plan_name']
        site_recommended_plan = site['plan_name']
        site_current_plan_index = 0
        site_recommended_plan_index = 0

        if site['plan_name'] == 'Sandbox':
            sc.console.print(f'{site["name"]} is on the Sandbox plan, skipping it.')
            continue

        if site['frozen'] is not False:
            sc.console.print(f':exclamation: [bold red] ATTENTION: {site["name"]} is frozen!')
            site_notices.append({
                'type': 'alert',
                'icon': '&#x1F6A8;',  # police car light
                'csv': f'{site["name"]},frozen',
                'short': 'unfreeze site',
                'message': f'''
<p>Website <strong>{site["name"]}</strong> is frozen!</p>
<p><a href="https://docs.pantheon.io/guides/platform-considerations/platform-site-info#inactive-site-freezing">
This should not happen</a> to a website on a paid Pantheon plan.</p>
<p><a href="https://its.umich.edu/computing/web-mobile/pantheon/support#support">Contact Pantheon</a> to get
<strong>{site["name"]}</strong> unfrozen and to find out what went wrong.</p>
''',
                'text': f'''
Website {site["name"]} is frozen!
<https://docs.pantheon.io/guides/platform-considerations/platform-site-info#inactive-site-freezing>

This should not happen</a> to a website on a paid Pantheon plan.
Contact Pantheon to get {site["name"]} unfrozen
and to find out what went wrong:
<https://its.umich.edu/computing/web-mobile/pantheon/support#support>
'''
            })

        if site['plan_name'] not in plan_names:
            sc.console.print(f':exclamation: [bold red] ATTENTION: {site["name"]} '
                          f'is on an unknown plan: {site["plan_name"]}')
            sys.exit('Bailing out.')

        # From https://docs.pantheon.io/guides/account-mgmt/traffic/overages
        # FAQ 1 as of April 25, 2024:
        # "Only traffic for the Live environment is counted towards a site plan's traffic limit."

        # The live environment will always exist, but may not be initialized.
        envs = terminus('env:list', site['id'])
        if 'live' not in envs or 'initialized' not in envs['live']:
            sc.console.print(f':exclamation: [bold red] ERROR: {site["name"]} does not have a live environment, '
                             'this should never happen')
            sys.exit('Bailing out.')
        if envs['live']['initialized'] is False:
            sc.console.print(f':exclamation: [bold red] ERROR: {site["name"]} is on a paid plan but its live '
                             'environment is not initialized')
            site_notices.append({
                'type': 'alert',
                'icon': '&#x1F6A8;',  # police car light
                'csv': f'{site["name"]},no-live-env-but-paid-plan',
                'short': f'no live environment',
                'message': f'''
            <p>{site["name"]} is on a paid plan but its live environment is not initialized.  Either initialize
            the live environment and connect a domain through which people will access the site or downgrade the
            site's plan to Sandbox to save money.</p>
            ''',
                'text': f"""
            {site["name"]} is on a paid plan but its
            live environment is not initialized.  Either initialize the
            live environment and connect a domain through which people
            will access the site or downgrade the site's plan to
            Sandbox to save money.
            """,
            })

        # Metrics for an uninitialized live environment will be all zeroes; this is OK.

        live_site = site['id'] + '.live'
        metrics = terminus('env:metrics', live_site, '--period=day')

        sc.debug(f'[bold magenta]=== Updating metrics for {site["name"]}:')
        # Preload the session with the data we're going to be updating.  This makes the call to `db_session.merge()`
        # in the loop below much faster.
        _ = db_session.query(PantheonTraffic).filter(PantheonTraffic.site_id == site['id'],
                                                  PantheonTraffic.traffic_date.between(start_date, end_date)
                                                  ).all()

        for e in metrics['timeseries']:
            entry = metrics['timeseries'][e]
            traffic_date = datetime.datetime.strptime(entry['datetime'], '%Y-%m-%dT%H:%M:%S').date()
            if traffic_date == end_date:
                continue  # skip today's partial data
            traffic = PantheonTraffic(site_id=site['id'],
                                      traffic_date=traffic_date,
                                      site_plan=site['plan_name'],
                                      visits=entry['visits'],
                                      pages_served=entry['pages_served'],
                                      cache_hits=entry['cache_hits'])
            db_session.merge(traffic)

        db_session.commit()

        if sc.options.import_older_metrics:
            sc.console.print(f'[bold magenta]=== Importing older metrics for {site["name"]}:')

            # Process old data by week:
            new_rows = get_old_metrics(live_site, site, 'week', end_date)
            if len(new_rows) > 0:
                if sc.config['Database']['type'] == 'sqlite':
                    db_session.execute(sqlite_insert(PantheonTraffic).on_conflict_do_nothing(index_elements=['site_id', 'traffic_date']), new_rows)
                else: # mysql:
                    db_session.execute(insert(PantheonTraffic).prefix_with('IGNORE'), new_rows)
                db_session.commit()

            # Process old data by month:
            new_rows = get_old_metrics(live_site, site, 'month', end_date)
            if len(new_rows) > 0:
                if sc.config['Database']['type'] == 'sqlite':
                    db_session.execute(sqlite_insert(PantheonTraffic).on_conflict_do_nothing(index_elements=['site_id', 'traffic_date']), new_rows)
                else: # mysql:
                    db_session.execute(insert(PantheonTraffic).prefix_with('IGNORE'), new_rows)
                db_session.commit()

            continue  # skip the rest of the processing for the sites

        if sc.options.update:
            sc.console.print('site visitors updated, skipping report')
            continue

        # Get all the data we will use:
        results = db_session.query(PantheonTraffic).filter(PantheonTraffic.site_id == site['id'],
                                                        PantheonTraffic.traffic_date.between(start_date, end_date)
                                                        ).all()

        sc.debug(f'{len(results)} records found in the database for {site["name"]} '
                      f'between {start_date} and {end_date}:', level=2)
        # for row in results:
        #    sc.debug(row, level=2)

        site_context = {
            'site':         site,
            'notices':      site_notices,
            'sections':     [],  # list of sections in the email
            'attachments':  [],  # list of attachments to be included in the email
        }
        sc.invoke_hooks('check', site_context)

        # Get the list of all proxied Cloudflare FQDNs.
        # This file is created by running the following cloudflare-support-tools command:
        #   get_proxied_fqdns --output fqdns.json
        # Warn if the file pointed to by the symlink is more than a day old.
        proxied_fqdns_file = 'fqdns.json'
        if os.path.islink(proxied_fqdns_file):
            proxied_fqdns_file = os.readlink(proxied_fqdns_file)
        if time.time() - os.path.getmtime(proxied_fqdns_file) > 86400:
            sc.console.print(f':exclamation: [bold red] ATTENTION: {proxied_fqdns_file} is more than a day old!')
            if sc.options.all:
                sys.exit('Exiting because --all was specified. Please update fqdns.json')
        with open(proxied_fqdns_file, 'r') as f:
            proxied_fqdns = json.load(f)

        # Query Pantheon for the site's domains
        # TODO: check domains for site
        #   - In Cloudflare, do they all point at the correct Pantheon IPs?
        #   - If not in Cloudflare and are not DNS zone apexes, are they CNAMES (not A / AAAA) to live-${site_name}.pantheonsite.io?
        #   - Take into account CNAME chaining for these checks
        domains = terminus('domain:list', live_site)
        if sc.options.verbose:
            sc.debug(f'=== Domains for {site["name"]}:')
            pprint(domains)
        site_url = ''
        main_fqdn = ''
        dns_points_at_cloudflare = 0
        dns_points_elsewhere = 0
        not_behind_cloudflare = []
        not_in_dns = []
        behind_cloudflare_not_proxied = []
        if isinstance(domains, dict):
            for d in domains.keys():
                domain = domains[d]
                if domain['type'] == 'platform':
                    continue
                hostname = domain['id']
                if not fqdn_re.match(hostname):
                    sc.console.log(f'[bold red]ERROR: Invalid domain for {site["name"]}: {hostname}')
                    continue
                if domain['primary'] or main_fqdn == '':
                    main_fqdn = hostname
                try:
                    a = dns.resolver.resolve(hostname, 'A')
                    for rdata in a:
                        address = ipaddress.ip_address(rdata.address)
                        if cloudflare_enabled and any([address in net for net in sc.plugin_context['plugin.cloudflare']['cloudflare_ipv4_nets']]):
                            dns_points_at_cloudflare += 1
                            sc.console.print(
                                f'{hostname} has [green]Cloudflare IP address {rdata.address}[/green]')
                        else:
                            dns_points_elsewhere += 1
                            sc.console.print(f'{hostname} has IP address [red]{rdata.address}[/red]')
                except dns.resolver.NoAnswer:
                    sc.console.print(f'No A record for {hostname}', style='red')
                except dns.resolver.NXDOMAIN:
                    sc.console.print(f'NXDOMAIN for {hostname} (A)', style='red')
                except dns.resolver.NoNameservers:
                    sc.console.print(f'No nameservers for {hostname}', style='red')
                except dns.resolver.Timeout:
                    sc.console.print(f'Timeout resolving {hostname}', style='red')

                try:
                    aaaa = dns.resolver.resolve(hostname, 'AAAA')
                    for rdata in aaaa:
                        address = ipaddress.ip_address(rdata.address)
                        if cloudflare_enabled and any([address in net for net in sc.plugin_context['plugin.cloudflare']['cloudflare_ipv6_nets']]):
                            dns_points_at_cloudflare += 1
                            sc.console.print(
                                f'{hostname} has [green]Cloudflare IP address {rdata.address}[/green]')
                        else:
                            dns_points_elsewhere += 1
                            sc.console.print(f'{hostname} has IP address [red]{rdata.address}[/red]')
                except dns.resolver.NoAnswer:
                    sc.console.print(f'No AAAA record for {hostname}')
                except dns.resolver.NXDOMAIN:
                    sc.console.print(f'NXDOMAIN for {hostname} (AAAA)', style='red')
                except dns.resolver.NoNameservers:
                    sc.console.print(f'No nameservers for {hostname}', style='red')
                except dns.resolver.Timeout:
                    sc.console.print(f'Timeout resolving {hostname}', style='red')

                if dns_points_at_cloudflare == 0 and dns_points_elsewhere == 0:
                    sc.console.print(f':exclamation: [bold red] ATTENTION: {hostname} is not in DNS')
                    not_in_dns.append(hostname)
                if cloudflare_enabled:
                    if dns_points_at_cloudflare == 0 or dns_points_elsewhere != 0:
                        sc.console.print(f':exclamation: [bold red] ATTENTION: {hostname} is not behind Cloudflare')
                        not_behind_cloudflare.append(hostname)
                    if dns_points_at_cloudflare > 0 and hostname not in proxied_fqdns:
                        sc.console.print(f':exclamation: [bold red] ATTENTION: {hostname} is behind Cloudflare but not proxied')
                        behind_cloudflare_not_proxied.append(hostname)

            custom_domains = [d for d in domains.keys() if domains[d]['type'] == 'custom']
            primary_domain = [d for d in custom_domains if domains[d]['primary']]
            if len(custom_domains) == 0:
                site_notices.append({
                    'type': 'alert',
                    'icon': '&#x1F6A8;',  # police car light
                    'csv': f'{site["name"]},no-domains',
                    'short': f'no domains connected',
                    'message': f'''
                <p>{site["name"]} is on a paid plan but does not have any custom domains connected.  Either connect
                a domain through which people will access the site or downgrade the site's plan to Sandbox to save
                money.</p>
                ''',
                    'text': f"""
                {site["name"]} is on a paid plan but does not have
                any custom domains connected. Either connect a domain through
                which people will access the ste or downgrade the site's plan
                to Sandbox to save money.
                """,
                })
            if len(custom_domains) > 1 and len(primary_domain) == 0 and site['framework'] != 'wordpress_network':
                is_multisite = False
                if site['framework'].startswith('drupal'):
                    sites_file, errors, fatal = drush_php_eval(
                        live_site,
                        'echo json_encode( ["result" => (is_file("/code/web/sites/sites.php") || is_file("/code/sites/sites.php") ? true : false) ] );'
                    )
                    if fatal or sites_file is None:
                        site_notices += drush_error( site['name'], 'multisite-check',
                             f'The check for whether {site["name"]} is a Drupal multisite failed.', errors)
                    elif errors != '':
                        drush_smell = errors
                    if isinstance(sites_file, dict) and 'result' in sites_file and sites_file['result'] == True:
                        is_multisite = True
                    sc.console.print(f'{site["name"]} is a Drupal multisite: {sites_file}')
                if not is_multisite:
                    site_notices.append({
                        'type': 'info',
                        'icon': '&#x1F50E;',  # magnifying glass
                        'csv': f'{site["name"]},no-primary-domain,',
                        'short': f'set a primary domain',
                        'message': f'''
                    <p><strong>{site['name']}</strong>
                    <a href="https://dashboard.pantheon.io/sites/{site['id']}#live/DomainsHTTPS/list">
                    does not have a primary domain set</a> in the Pantheon dashboard. Setting a
                    <a href="https://docs.pantheon.io/guides/redirect/primary-domain">primary domain</a> will improve SEO.
                    It will also increase the Cloudflare cache hit ratio, lowering Pantheon visitor numbers.</p>
                    <p><i>Do not set a primary domain if </i><strong>{site['name']}</strong><i> is a multisite.</i></p>
                    ''',
                        'text': f'''
                    {site['name']} does not have a primary domain set
                    in the Pantheon dashboard.
                    <https://dashboard.pantheon.io/sites/{site['id']}#live/DomainsHTTPS/list>
                    Setting a primary domain
                    <https://docs.pantheon.io/guides/redirect/primary-domain>
                    will improve SEO. It will also increase the Cloudflare
                    cache hit ratio, lowering Pantheon visitor numbers.

                    DO NOT set a primary domain if {site['name']} is a
                    multisite.
                    '''
                    })

        if main_fqdn != '':
            site_url = f'https://{main_fqdn}/'
        sc.debug(f'Main domain for {site["name"]}: {main_fqdn}')

        if len(not_behind_cloudflare) > 0:
            site_notices.append({
                'type': 'warning',
                'icon': '&#x26A0;',  # warning sign
                'csv': f'{site["name"]},not-behind-cloudflare,' + ','.join(not_behind_cloudflare),
                'short': 'put domains behind Cloudflare',
                'message': f'''
<p>ITS strongly recommends you put the following domains behind Cloudflare to reduce Pantheon traffic and improve
security.  Please refer to the <a href="https://its.umich.edu/computing/web-mobile/cloudflare/getting-started">
Cloudflare at U-M documentation</a>.</p>
<ul style="list-style-type: none;">
{"\n".join([f'<li><a href="https://{escape_url(n)}/">{html.escape(n)}</a></li>' for n in not_behind_cloudflare])}
</ul>
''',
                'text': f'''
ITS strongly recommends you put the following domains behind
Cloudflare to reduce Pantheon traffic and improve security.
Please refer to the Cloudflare at U-M documentation
<https://its.umich.edu/computing/web-mobile/cloudflare/getting-started>

{"\n".join([f'  * {n}' for n in not_behind_cloudflare])}

'''
            })

            if len(behind_cloudflare_not_proxied) > 0:
                site_notices.append({
                    'type': 'warning',
                    'icon': '&#x26A0;',  # warning sign
                    'csv': f'{site["name"]},behind-cloudflare-not-proxied,' + ','.join(behind_cloudflare_not_proxied),
                    'short': 'turn on Cloudflare proxying for domains',
                    'message': f'''
<p>The following domains point to Cloudflare but are not benefitting from Cloudflare's caching and security
features because proxying for these FQDNs is turned off in Cloudflare.  Please follow steps 3 and 4 of the
<a href="https://documentation.its.umich.edu/node/4237">U-M Cloudflare: Website Migration Steps</a> to ensure
the site is configured to work with Cloudflare and to turn on proxying.<p>
<ul style="list-style-type: none;">
{"\n".join([f'<li><a href="https://{escape_url(n)}/">{html.escape(n)}</a></li>' for n in behind_cloudflare_not_proxied])}
</ul>
''',
            'text': f'''
The following domains point to Cloudflare but are not benefitting from
Cloudflare's caching and security features because proxying for these
FQDNs is turned off in Cloudflare.

Please follow steps 3 and 4 of the U-M Cloudflare: Website Migration
Steps <"https://documentation.its.umich.edu/node/4237> to ensure the
site is configured to work with Cloudflare and to turn on proxying.

{"\n".join([f'  * {n}' for n in not_behind_cloudflare])}

'''
                })

        if len(not_in_dns) > 0:
            site_notices.append({
                'type': 'alert',
                'icon': '&#x1F6A8;',  # police car light
                'csv': f'{site["name"]},not-in-dns,' + ','.join(not_in_dns),
                'short': 'add domains to DNS',
                'message': f'''
<p><strong>{site["name"]}</strong> has domains that are not in DNS.  Please either remove these domains from
the Pantheon live environment for <strong>{site["name"]}</strong>, or add them to DNS.</p>
<ul style="list-style-type: none;">
{"\n".join([f'<li><a href="https://{escape_url(n)}/">{html.escape(n)}</a></li>' for n in not_in_dns])}
</ul>
''',
                'text': f'''
{site["name"]} has domains that are not in DNS.  Please either
remove these domains from the Pantheon live environment for
{site["name"]}, or add them to DNS.

{"\n".join([f'  * {n}' for n in not_in_dns])}

'''
            })

        # Check the site's plugins/modules

        add_on_updates = []
        if site['framework'].startswith('wordpress'):
            sc.console.print(f'[bold magenta]=== Getting WordPress version for {site["name"]}:')
            wordpress_version, errors, fatal = wp_eval(
                live_site,
                'require ABSPATH . WPINC . "/version.php"; echo $wp_version;'
            )
            if fatal or wordpress_version is None:
                site_notices += wp_error(site['name'],
                    'version-check', f'Unable to check WordPress version for {site["name"]}.',
                    errors)
            elif errors != '':
                wp_smell = errors
            sc.debug(f'{site["name"]} WordPress version: {wordpress_version}')
            if not isinstance(wordpress_version, str):
                wordpress_version = 'unknown'
            wordpress_version = wordpress_version.strip()
            site_results[site['name']] = {
                'framework': site['framework'],
                'version': wordpress_version,
                'plan_name': site['plan_name'],
            }
            sc.console.print(f'[bold magenta]=== Checking WordPress plugins for {site["name"]}:')
            plugins, errors, fatal = wp(live_site, 'plugin', 'list', '--fields=name,status,update,version,update_version,title')
            if fatal or plugins is None:
                site_notices += wp_error(site['name'],
                    'plugin-list', f'Unable to run <code>wp plugin list</code> for {site["name"]}.',
                    errors)
            elif errors != '':
                wp_smell = errors
            if sc.options.verbose:
                pprint(plugins)
            site_notices += check_wordpress_plugin(
                site['name'],
                plugins,
                'pantheon-advanced-page-cache',
                'Pantheon Advanced Page Cache',
                'https://docs.pantheon.io/guides/wordpress-configurations/wordpress-cache-plugin',
                'Needed for automatically clearing Pantheon\'s caches (not Cloudflare\'s) when content is updated.'
            )
            site_notices += check_wordpress_plugin(
                site['name'],
                plugins,
                'wp-native-php-sessions',
                'Native PHP Sessions for WordPress',
                'https://docs.pantheon.io/guides/php/wordpress-sessions#install-wordpress-native-php-sessions-plugin',
                'Strongly recommended to ensure PHP sessions work correctly on Pantheon.'
            )
            if dns_points_at_cloudflare > 0:
                site_notices += check_wordpress_plugin(
                    site['name'],
                    plugins,
                    'umich-cloudflare',
                    'University of Michigan: Cloudflare Cache',
                    'https://documentation.its.umich.edu/node/5114',
                    'Needed for automatically clearing Cloudflare\'s caches when content is updated.'
                )
            if isinstance(plugins, list):
                for p in plugins:
                    if p['update'] == 'available':
                        add_on_updates.append({
                            'slug': p['name'],
                            'name': p['title'],
                            'type': 'plugin',
                            'current_version': p['version'],
                            'new_version': p['update_version'],
                        })
                    if p['status'] == 'must-use' and p['name'] != 'loader':
                        sc.console.print(f'[bold yellow]{site["name"]} has must-use plugin:')
                        pprint(p)
                # Special check for our fork of Hummingbird (version number contains 'umich')
                name = 'hummingbird-performance'
                display_name = 'UMich Hummingbird'
                url = 'https://documentation.its.umich.edu/node/4243'
                url2 = 'https://documentation.its.umich.edu/node/5114'
                reason = 'UMich Hummingbird is unsupported and has been replaced by University of Michigan: Cloudflare Cache'
                installed = [p for p in plugins if p['name'] == name and 'umich' in p['version']]
                if len(installed) != 0:
                    plugin = installed[0]
                    sc.console.print(f':exclamation: [bold red] ATTENTION: {site} has {display_name} installed.')
                    if 'status' in plugin and plugin['status'] == 'inactive':
                        site_notices.append({
                            'type': 'info',
                            'icon': '&#x1F50E;',  # magnifying glass
                            'csv': f'{site["name"]},unsupported-turned-off,{name}',
                            'short': f'delete inactive plugin {name}',
                            'message': f'<p>The <a href="{escape_url(url)}">{html.escape(display_name)}</a> WordPress plugin is inactive but should be deleted:</p><p>{html.escape(reason)}</p>',
                            'text': f"The {display_name} WordPress plugin\n<{url}>\nis inactive but should be deleted: {reason}",
                        })
                    else:
                        site_notices.append({
                            'type': 'alert',
                            'icon': '&#x1F6A8;',  # police car light
                            'csv': f'{site["name"]},unsupported,{name}',
                            'short': f'replace plugin {name} with umich-cloudflare',
                            'message': f'''
<p>The <a href="{escape_url(url)}">{html.escape(display_name)}</a> WordPress plugin needs to be replaced! It is unsupported and out of date.</p>
<p>Please install the <a href="{escape_url(url2)}">University of Michigan: Cloudflare Cache</a> plugin and remove {html.escape(display_name)}.</p>
''',
                        'text': f"""
The {display_name} WordPress plugin\n<{url}>\nneeds to be replaced!
It is unsupported and out of date.

Please install the University of Michigan: Cloudflare Cache
<{url2}>
plugin and remove {display_name}.
""",
                        })
            sc.console.print(f'[bold magenta]=== Checking WordPress themes for {site["name"]}:')
            themes, errors, fatal = wp(live_site, 'theme', 'list', '--fields=name,status,update,version,update_version,title')
            if fatal or themes is None:
                site_notices += wp_error(site['name'],
                    'plugin-list', f'Unable to run <code>wp theme list</code> for {site["name"]}.',
                    errors)
            elif errors != '':
                wp_smell = errors
            if sc.options.verbose:
                pprint(themes)
            if isinstance(themes, list):
                for t in themes:
                    if t['update'] == 'available':
                        add_on_updates.append({
                            'slug': t['name'],
                            'name': t['title'],
                            'type': 'theme',
                            'current_version': t['version'],
                            'new_version': t['update_version'],
                        })
            # This isn't a plugin, but here is a good place to check for it.
            favicon, errors, fatal = wp_eval(live_site, 'echo is_file("favicon.ico") ? "true": "false";')
            if fatal or favicon is None:
                site_notices += wp_error(site['name'],
                    'favicon-check', f'Unable to check for <code>/favicon.ico</code> file for {site["name"]}.',
                    errors)
            elif errors != '':
                wp_smell = errors
            sc.debug(f'{site["name"]} has a favicon.ico file: {favicon}')
            if isinstance(favicon, str) and favicon.startswith('false') and len(not_behind_cloudflare) > 0:
                site_notices.append({
                    'type': 'warning',
                    'icon': '&#x26A0;',  # warning sign
                    'csv': f'{site["name"]},no-favicon',
                    'short': 'add favicon.ico file',
                    'message': f'<p><a href="https://its.umich.edu/computing/web-mobile/cloudflare/getting-started">Put this site behind Cloudflare</a> or add a <a href="https://en.wikipedia.org/wiki/Favicon"><code>/code/favicon.ico</code> file</a> to lower Pantheon visitor numbers and increase the site\'s traffic capacity.</p>',
                    'text': f"Put this site behind Cloudflare\n<https://its.umich.edu/computing/web-mobile/cloudflare/getting-started>\nor add a /code/favicon.ico file\n<https://en.wikipedia.org/wiki/Favicon>\nto lower Pantheon visitor numbers and increase the amount of traffic the site can handle at any time.",
                })

        elif site['framework'].startswith('drupal'):
            sc.console.print(f'[bold magenta]=== Checking Drupal modules for {site["name"]}:')
            drupal_status, errors, fatal = drush(live_site, 'core-status')
            if fatal or drupal_status is None:
                site_notices += drush_error(site['name'],
                    'core-status', f'Unable to run <code>drush core-status</code> for {site["name"]}.',
                    errors)
            elif errors != '':
                drush_smell = errors
            if sc.options.verbose:
                pprint(drupal_status)
            drupal_version = drupal_status['drupal-version'] \
                if isinstance(drupal_status, dict) and 'drupal-version' in drupal_status \
                else 'unknown'
            site_results[site['name']] = {
                'framework': site['framework'],
                'version': drupal_version,
                'plan_name': site['plan_name'],
            }
            mods, errors, fatal = drush(live_site, 'pm:list')
            if fatal or mods is None:
                site_notices += drush_error(site['name'],
                    'pm-list', f'Unable to run <code>drush pm:list</code> for {site["name"]}.',
                    errors)
            elif errors != '':
                drush_smell = errors
            if sc.options.verbose:
                pprint(mods)
            site_notices += check_drupal_module(
                site['name'],
                mods,
                'pantheon_advanced_page_cache',
                'Pantheon Advanced Page Cache',
                'https://www.drupal.org/project/pantheon_advanced_page_cache',
                'Necessary for automatically clearing Pantheon\'s caches (not Cloudflare\'s) when content is updated.'
            )
            if drupal_version.startswith('7.'):
                site_notices += check_drupal_module(
                    site['name'],
                    mods,
                    'tag1_d7es',
                    'Tag1 D7ES',
                    'https://docs.pantheon.io/supported-drupal#drupal-7-long-term-support',
                    'Necessary for receiving extended support for Drupal 7.'
                )
            else:
                if dns_points_at_cloudflare > 0:
                    site_notices += check_drupal_module(
                        site['name'],
                        mods,
                        'cloudflare',
                        'CloudFlare', # note: capital F here
                        'https://documentation.its.umich.edu/node/4242',
                        'Necessary for automatically clearing Cloudflare\'s caches when content is updated.'
                    )
                    site_notices += check_drupal_module(
                        site['name'],
                        mods,
                        'cloudflarepurger',
                        'CloudFlare Purger',
                        'https://documentation.its.umich.edu/node/4242',
                        'Necessary for automatically clearing Cloudflare\'s caches when content is updated.'
                    )
            if drupal_version.startswith('7.'):
                updates, errors, fatal = drush(live_site, 'pm:updatestatus', '--full')
                if fatal:
                    site_notices += drush_error(site['name'],
                                                'pm-updatestatus',
                                                f'Unable to run <code>drush pm:updatestatus</code> for {site["name"]}.',
                                                errors)
                # elif errors != '':
                #     drush_smell = errors  # there will always be verbose progress output for pm:upstatestatus
                if sc.options.verbose:
                    pprint(updates)
                if isinstance(updates, dict):
                    for package in updates:
                        u = updates[package]
                        current_version = u['existing_version']
                        new_version = current_version
                        if 'candidate_version' in u:
                            new_version = u['candidate_version']
                        elif 'recommended' in u:
                            new_version = u['recommended']
                        elif 'latest_version' in u:
                            new_version = u['latest_version']
                        if new_version == current_version:
                            new_version = f'none: {u["project_status"]}'
                        add_on_updates.append({
                            'slug': package,
                            'name': f'<a href="{escape_url(u["link"])}">{html.escape(u["title"])}</a>',
                            'type': u['type'] if type in u else 'package',
                            'current_version': current_version,
                            'new_version': new_version,
                        })
            else:
                sc.console.print(f'[bold magenta]=== Dry-run update for packages on {site["name"]}:')
                command = ['composer', live_site, '--', 'update', '--dry-run']
                updates, errors, fatal = run_terminus(command)
                if fatal or updates is None:
                    site_notices.append({
                        'type': 'alert',
                        'icon': '&#x1F6A8;',  # police car light
                        'csv': f'{site["name"]},composer-update',
                        'short': f'fix composer error',
                        'message': f'''
                    <p>Unable to run <code>composer update --dry-run</code> for {site["name"]}.
                    <code>composer</code> returned the following error:</p>
                    <pre>{html.escape(errors)}</pre>
                    ''',
                        'text': f'''
                    Unable to run 'composer update --dry-run' for {site["name"]}.
                    composer returned the following error:

                    ----- START DRUSH ERROR -----
                    {errors}
                    ----- END ERROR -----

                    ''',
                    })
                elif errors != '':
                    composer_smell = errors
                if sc.options.verbose:
                    pprint(updates)
                package_updates = {}
                if isinstance(updates, str):
                    for line in updates.split('\n'):
                        # Example line:
                        # - Upgrading drupal/admin_toolbar (3.4.2 => 3.5.3)
                        m = re.search(r'^\s*-\s+Upgrading\s+(\S+)\s+\((.+) => (.+)\)\s*$', line)
                        if m:
                            package_updates[m.group(1)] = {
                                'current': m.group(2),
                                'new': m.group(3),
                            }
                sc.console.print(f'[bold magenta]=== Running audit for packages on {site["name"]}:')
                audit = terminus('composer', live_site, '--', 'audit')
                if isinstance(audit, dict):
                    if 'advisories' in audit:
                        package_list = audit['advisories']
                        for package in package_list:
                            vuln = []
                            advisory_list = package_list[package]
                            for advisory in advisory_list:
                                if isinstance(advisory, str):
                                    advisory = package_list[package][advisory]
                                if sc.options.verbose:
                                    sc.console.print(f'[bold yellow]Advisory for {package}:')
                                    pprint(advisory)
                                title = advisory['title']
                                t = title.split(' - ')
                                if advisory['severity']:
                                    severity = advisory['severity']
                                elif len(t) == 4:
                                    severity = t[1]
                                    title = ' - '.join([ t[0], t[2], t[3] ])
                                else:
                                    severity = 'unknown'
                                vuln.append({
                                    'title': f'<a href="{escape_url(advisory["link"])}">{html.escape(title)}</a>',
                                    'severity': severity,
                                })
                            current_version = 'unknown'
                            new_version = 'unknown'
                            new_version_url = None
                            if package in package_updates:
                                if 'current' in package_updates[package]:
                                    current_version = package_updates[package]['current']
                                if 'new' in package_updates[package]:
                                    new_version = package_updates[package]['new']
                                elif 'cve' in package_updates[package]:
                                    cve = package_updates[package]['cve']
                                    new_version = f'See {cve}'
                                    new_version_url = f'https://nvd.nist.gov/vuln/detail/{cve}'
                            if new_version == 'unknown':
                                new_version = 'See advisory'
                                new_version_url = advisory["link"]
                            a = {
                                'slug': package,
                                'name': vuln,
                                'type': 'package',
                                'current_version': current_version,
                                'new_version': new_version,
                            }
                            if new_version_url:
                                a['new_version_url'] = new_version_url
                            add_on_updates.append(a)
                    if 'abandoned' in audit and len(audit['abandoned']) > 0:
                        sc.console.print('[bold yellow]Abandoned packages:')
                        pprint(audit['abandoned'])
                else:
                    sc.console.print(f'[bold red]Unable to run <code>composer audit</code> for {site["name"]}')
                if sc.options.verbose:
                    pprint(audit)

        else:
            sc.console.print(f':exclamation: [bold red] ATTENTION: unknown framework for {site["name"]}: {site["framework"]}')

        # Check for un-applied site updates:

        sc.console.print(f'[bold magenta]=== Checking for unapplied updates for {site["name"]}:')
        updates = terminus('upstream:updates:list', live_site)
        if isinstance(updates, list):
            num_updates = len(updates)
            if num_updates > 0:
                update_times = [datetime.datetime.fromisoformat(update['datetime']).replace(tzinfo=datetime.UTC) for update in updates]
                oldest_update = min(update_times)
                oldest_update_days = (datetime.datetime.now(datetime.UTC) - oldest_update).days
                sc.console.print(f'{site["name"]} has {num_updates} unapplied updates from Pantheon, the oldest from {oldest_update_days} days ago ( {oldest_update} )')
                update_table_rows = ''
                update_bullet_list = ''
                for i, update in enumerate(updates):
                    update_release_date = datetime.datetime.fromisoformat(update['datetime']).strftime('%B %e, %Y')
                    background_color = '#fff' if i % 2 == 0 else '#CCCFCA'
                    update_table_rows += f'''
<tr style="background-color: {background_color};">
<td><div class="rt-data-header rt-plan">Date</div><div class="rt-data rt-plan">{update_release_date}</div></td>
<td><div class="rt-data-header rt-plan">Description</div><div class="rt-data rt-plan">{update['message']}</div></td>
<td><div class="rt-data-header rt-plan">Author</div><div class="rt-data rt-plan">{update['author']}</div></td>
</tr>
'''
                    update_bullet_list += f'''
* {update_release_date}
  - {update['message']}
  - Author: {update['author']}

'''
                if oldest_update_days <= 7:
                    site_notices.append({
                        'type': 'info',
                        'icon': '&#x1F50E;',  # magnifying glass
                        'csv': f'{site["name"]},updates-info,{num_updates},{oldest_update_days}',
                        'short': f'{num_updates} pending Pantheon updates' if num_updates > 1 else '1 pending Pantheon update',
                        'message': f'''
<p><strong>{site['name']}</strong> has
<a href="https://dashboard.pantheon.io/sites/{site['id']}#dev/code">{num_updates} pending recent updates from Pantheon</a>.</p>
<div class="container">
<table class="responsive-table site-updates">
<thead><th class="rt-plan">Date</th><th class="rt-plan">Description</th><th class="rt-plan">Author</th></thead>
<tbody>{update_table_rows}</tbody>
</table>
</div>
<p>How to: <a href="https://docs.pantheon.io/core-updates">apply updates</a>,
<a href="https://docs.pantheon.io/pantheon-workflow">deploy updates</a>,
<a href="https://its.umich.edu/computing/web-mobile/pantheon/support">get support</a>.</p>
''',
                        'text': f'''
{site['name']} has {num_updates} pending recent updates from Pantheon
<https://dashboard.pantheon.io/sites/{site['id']}#dev/code>.

{update_bullet_list}
How to:
  * apply updates <https://docs.pantheon.io/core-updates>
  * deploy updates <https://docs.pantheon.io/pantheon-workflow>,
  * get support <https://its.umich.edu/computing/web-mobile/pantheon/support>
''',
                    })
                elif oldest_update_days <= 30:
                    site_notices.append({
                        'type': 'warning',
                        'icon': '&#x26A0;',  # warning sign
                        'csv': f'{site["name"]},updates-warning,{num_updates},{oldest_update_days}',
                        'short': f'{num_updates} pending Pantheon updates' if num_updates > 1 else '1 pending Pantheon update',
                        'message': f'''
<p><strong>{site['name']}</strong> has
<a href="https://dashboard.pantheon.io/sites/{site['id']}#dev/code">{num_updates} pending updates from Pantheon</a>, the oldest
from {oldest_update_days} days ago.</p>
<p>Please <a href="https://docs.pantheon.io/core-updates">apply these updates</a> and
<a href="https://docs.pantheon.io/pantheon-workflow">deploy them to the Live environment</a>.
<a href="https://its.umich.edu/computing/web-mobile/pantheon/support">A variety of support options are available</a>.</p>
<div class="container">
<table class="responsive-table site-updates">
<thead><th class="rt-plan">Date</th><th class="rt-plan">Description</th><th class="rt-plan">Author</th></thead>
<tbody>{update_table_rows}</tbody>
</table>
</div>
''',
                        'text': f'''
{site['name']} has {num_updates} pending updates from Pantheon
<https://dashboard.pantheon.io/sites/{site['id']}#dev/code>, the
oldest from {oldest_update_days} days ago. Please apply these updates
<https://docs.pantheon.io/core-updates> and deploy them to the
Live environment. <https://docs.pantheon.io/pantheon-workflow>
A variety of support options are available.
<a href="https://its.umich.edu/computing/web-mobile/pantheon/support">

{update_bullet_list}
''',
                    })
                else:
                    site_notices.append({
                        'type': 'alert',
                        'icon': '&#x1F6A8;',  # police car light
                        'csv': f'{site["name"]},updates-alert,{num_updates},{oldest_update_days}',
                        'short': f'needs maintenance: {num_updates} Pantheon updates, oldest {oldest_update_days} days old' \
                            if num_updates > 1 else 'needs maintenance: 1 Pantheon update, {oldest_update_days} days old',
                        'message': f'''
<p><strong>{site['name']}</strong> has
<a href="https://dashboard.pantheon.io/sites/{site['id']}#dev/code">{num_updates} pending updates from Pantheon</a>, the oldest
from {oldest_update_days} days ago.</p>
<p><i>Please <a href="https://docs.pantheon.io/core-updates">apply these updates</a> immediately</i> and then
<a href="https://docs.pantheon.io/pantheon-workflow">deploy them to the Live environment</a>. Websites that are
unmaintained or insecure may be shut down to protect the university.</p>
<p>U-M Procurement has a <a href="https://procurement.umich.edu/u-m-employees/purchasing/ordering/quote-to-order/">list
of web agencies</a> that will maintain a website for you and bill a university shortcode. If you would like help
applying the updates yourself, you can <a href="https://its.umich.edu/computing/web-mobile/pantheon/support">obtain
support through either Pantheon or ITS</a>.</p>
<div class="container">
<table class="responsive-table site-updates">
<thead><th class="rt-plan">Date</th><th class="rt-plan">Description</th><th class="rt-plan">Author</th></thead>
<tbody>{update_table_rows}</tbody>
</table>
</div>
''',
                        'text': f'''
{site['name']} has {num_updates} pending updates from Pantheon
<https://dashboard.pantheon.io/sites/{site['id']}#dev/code>, the
oldest from {oldest_update_days} days ago.

PLEASE APPLY THESE UPDATES IMMEDIATELY
<https://docs.pantheon.io/core-updates> and then deploy them to the
Live environment. <https://docs.pantheon.io/pantheon-workflow>

Websites that are unmaintained or insecure may be shut down to protect
the university.

U-M Procurement has a list of web agencies
<https://procurement.umich.edu/u-m-employees/purchasing/ordering/quote-to-order/>
that will maintain a website for you and bill a university shortcode.
If you would like help applying the updates yourself, you can obtain
support through either Pantheon or ITS.
<a href="https://its.umich.edu/computing/web-mobile/pantheon/support">

{update_bullet_list}
''',
                    })

        else:
            sc.console.print(f':exclamation: [bold red] ERROR: unable to check updates for {site["name"]}')
            pprint(updates)

        if sc.options.verbose:
            sc.console.print(f'[bold yellow]=== Add-on updates for {site["name"]}:')
            pprint(add_on_updates)
        num_updates = len(add_on_updates)
        if num_updates > 0:
            update_table_rows = ''
            update_bullet_list = ''
            for i, update in enumerate(add_on_updates):
                name = update['name']
                if isinstance(name, list):
                    name = '\n'.join([f'{n["title"]}, ({n["severity"].upper()})<br /><br />' for n in name])
                if 'new_version_url' in update:
                    new_version = f'<a href="{escape_url(update["new_version_url"])}">{html.escape(update["new_version"])}</a>'
                else:
                    new_version = html.escape(update['new_version'])
                background_color = '#fff' if i % 2 == 0 else '#CCCFCA'
                update_table_rows += f'''
<tr style="background-color: {background_color};">
<td><div class="rt-data-header rt-plan">ID</div><div class="rt-data rt-plan">{html.escape(update['slug'])}</div></td>
<td><div class="rt-data-header rt-plan"">Name</div><div class="rt-data rt-plan">{name}</div></td>
<td><div class="rt-data-header rt-plan">Type</div><div class="rt-data rt-plan">{html.escape(update['type'])}</div></td>
<td><div class="rt-data-header rt-plan">Current version</div><div class="rt-data rt-plan">{html.escape(update['current_version'])}</div></td>
<td><div class="rt-data-header rt-plan">New version</div><div class="rt-data rt-plan">{new_version}</div></td>
</tr>
'''
                update_bullet_list += f'''
* {update['slug']}
  - Name: {update['name']}
  - Type: {update['type']}
  - Current version: {update['current_version']}
  - New version:     {update['new_version']}

'''
            site_notices.append({
                'type': 'warning',
                'icon': '&#x26A0;',  # warning sign
                'csv': f'{site["name"]},updates-addons,{num_updates}',
                'short': f'{num_updates} pending add-on updates' if num_updates > 1 else '1 pending add-on update',
                'message': f'''
<p><strong>{site['name']}</strong> has {num_updates} pending add-on updates.</p>
<p>Please update these add-ons in the site's Dev environment and
<a href="https://docs.pantheon.io/pantheon-workflow">deploy them to the Live environment</a>.
Uninstall any add-ons you are not using to improve your site's security, size, and speed.
<a href="https://its.umich.edu/computing/web-mobile/pantheon/support">A variety of support options are available</a>.</p>
<div class="container">
<table class="responsive-table site-updates">
<thead><th class="rt-plan">ID</th><th class="rt-plan">Name</th><th class="rt-plan">Type</th><th class="rt-plan">Current version</th><th class="rt-plan">New version</th></thead>
<tbody>{update_table_rows}</tbody>
</table>
</div>
''',
                'text': f'''
{site['name']} has {num_updates} pending add-on updates
<https://dashboard.pantheon.io/sites/{site['id']}#dev/code>.
Please update these add-ons in the site's Dev environment and deploy
them to the Live environment.
<https://docs.pantheon.io/pantheon-workflow>

Uninstall any add-ons you are not using to improve your site's
security, size, and speed.

A variety of support options are available.
<a href="https://its.umich.edu/computing/web-mobile/pantheon/support">

{update_bullet_list}
''',
            })

        # TODO: Warn if no Autopilot
        # TODO: check DNS and warn if the site is using Cloudflare IPs but is not a zone apex

        # TODO: instead of continuing here, proceed below to calculate plan recommendations, skipping the graph and email
        if sc.options.only_warn:
            for n in site_notices:
                all_warnings.append(n['csv'])
            continue

        # Create an array containing the sum of visits by month:
        visits_by_month = {}
        plan_on_day = {}
        d = start_date
        while d <= end_date:
            month = d.strftime('%Y-%m')
            visits_by_month[month] = 0
            d = d.replace(day=1) + datetime.timedelta(days=32)
            d = d.replace(day=1)
        for row in results:
            month = row.traffic_date.strftime('%Y-%m')
            visits_by_month[month] += row.visits
            plan_on_day[row.traffic_date] = row.site_plan
        if sc.options.verbose:
            pprint(visits_by_month)
            if sc.options.verbose > 1:
                pprint(plan_on_day)

        # Create a list of time ranges when the site was on each plan
        last_day = calendar.monthrange(end_date.year, end_date.month)[1]
        plot_right_date = end_date.replace(day=last_day)
        plan_over_time = []
        # noinspection PyTypeChecker
        days = sorted(plan_on_day.keys())
        plan = plan_on_day[days[0]]
        plan_start = days[0]
        for i in range(1, len(days)):
            today = days[i]
            if plan_on_day[today] != plan:
                plan_over_time.append({'start': plan_start, 'end': days[i - 1], 'plan': plan})
                plan_start = today
                plan = plan_on_day[plan_start]
        plan_over_time.append({'start': plan_start, 'end': plot_right_date, 'plan': plan})
        sc.debug(plan_over_time)

        # Convert the keys of the visits_by_month dictionary to datetime objects
        dates = [datetime.date.fromisoformat(d + '-15') for d in visits_by_month.keys()]
        visits = list(visits_by_month.values())
        visits_covered_by_month = {}
        first_plan_day = days[0]
        last_plan_day = days[-1]
        for month in visits_by_month.keys():
            ymd = datetime.date.fromisoformat(month + '-15')
            if ymd < first_plan_day:
                ymd = first_plan_day
            if ymd > last_plan_day:
                ymd = last_plan_day
            visits_covered_by_month[month] = min(visits_by_month[month], int(plan_info[plan_on_day[ymd]]['traffic_limit']))
        visits_covered = list(visits_covered_by_month.values())

        xbins = [datetime.datetime.strptime(d, '%Y-%m').replace(day=1) for d in visits_by_month.keys()]
        xbins.append(datetime.datetime.combine(plot_right_date, datetime.datetime.min.time())
                     + datetime.timedelta(days=1))

        # Convert dates to numerical format
        dates_num = mdates.date2num(np.array(dates))

        #
        # Create the chart
        #
        sc.debug(f'[bold magenta]=== Creating chart for {site["name"]}:')

        # Estimate the visits for the last month if it isn't over yet:
        estimate = -1
        if last_day > end_date.day > 1:
            extrapolate = visits_by_month[dates[-1].strftime('%Y-%m')] * last_day / (end_date.day - 1)
            if len(visits_by_month) > 1:
                previous_month = visits_by_month[dates[-2].strftime('%Y-%m')]
                if last_day >= 25:
                    estimate = round(extrapolate)
                elif last_day >= 15:
                    estimate = round((2 * extrapolate + previous_month) / 3)
                else:
                    estimate = round((extrapolate + previous_month) / 2)
            else:
                estimate = round(extrapolate)
            estimates_by_month = visits_covered_by_month.copy()
            for month in estimates_by_month.keys():
                estimates_by_month[month] = 0
            estimates_by_month[end_date_yyyy_mm] = estimate
            estimates = list(estimates_by_month.values())

        # figure out whether to show a traffic surge chart
        upgrade_at_max = 0
        for plan in plan_over_time:
            upgrade_at = plan_info[plan['plan']]['upgrade_at']
            if upgrade_at > upgrade_at_max:
                upgrade_at_max = upgrade_at
        surge_threshold = upgrade_at_max * 1.5
        visits_max = max(visits)
        surge = True if visits_max > surge_threshold else False

        visits_plan = [v if v <= surge_threshold else upgrade_at_max for v in visits]

        # set the plot height: top data point plus 15% for annotations and labels
        ymax = max(visits_max, upgrade_at_max) * 1.15

        if surge:
            fig = plt.figure()
            fig.set_size_inches(12, 12)
            gs = GridSpec(2, 1, height_ratios=[1, 2], hspace=0.1)
            ax_surge = fig.add_subplot(gs[0])
            ax_plan = fig.add_subplot(gs[1], sharex=ax_surge)
            axs = [ax_plan, ax_surge]
            ax_top = ax_surge
            ax_surge.set_ylim(surge_threshold, ymax)
            ax_plan.set_ylim(0, surge_threshold)
            ax_surge.spines.bottom.set_visible(False)
            ax_surge.xaxis.set_visible(False)
            ax_plan.spines.top.set_visible(False)
        else:
            fig, ax_plan = plt.subplots()
            fig.set_size_inches(12, 9)
            axs = [ax_plan]
            ax_top = ax_plan
            ax_plan.set_ylim(0, ymax)

        for ax in axs:

            est_bars = []
            if estimate >= 0:
                _, _, est_bars = ax.hist(dates_num, bins=xbins, weights=estimates, histtype='barstacked',
                                         color='lemonchiffon', edgecolor='black')
                est_labels = ax.bar_label(est_bars, fmt='{:,.0f}', backgroundcolor=(1.0, 1.0, 1.0, 0.0),
                                          fontstyle='italic', fontsize='small', padding=5, zorder=3.5,
                                          path_effects=[
                                              path_effects.Stroke(linewidth=3, foreground='white'),
                                              path_effects.Normal()
                                          ])
                for i in range(len(est_labels) - 1):
                    est_labels[i].set(visible=False)  # only show the label for the last month's estimate
                est_labels[-1].set_text(f'{estimate:,}\n(estimate)\n'
                                        f'{last_plan_day.strftime("%b ") + str(last_plan_day.day)}')
                est_labels[-1].set_fontsize('small')
                est_labels[-1].set_path_effects([path_effects.Stroke(linewidth=3, foreground='white'),
                                                 path_effects.Normal()])

            _, _, bars = ax.hist(dates_num, bins=xbins, weights=visits, histtype='barstacked', color='tab:pink',
                                 edgecolor='black')
            ax.bar_label(bars,
                         labels=[ f'{v:,.0f}' for v in visits ],
                         backgroundcolor=(1.0, 1.0, 1.0, 0.0),
                         fontweight='bold',
                         padding=5,
                         path_effects=[
                             path_effects.Stroke(linewidth=3, foreground='white'),
                             path_effects.Normal()
                         ])

        gap_bars = []
        gap_bars.extend(est_bars)
        gap_bars.extend(bars)

        # these bars are both below surge_threshold, so we only need to draw them on the plan portion of the chart
        ax_plan.hist(dates_num, bins=xbins, weights=visits_plan, histtype='barstacked', color='tab:cyan',
                     edgecolor='black')
        ax_plan.hist(dates_num, bins=xbins, weights=visits_covered, histtype='barstacked', color='tab:blue',
                     edgecolor='black')

        # Format the x-axis ticks to be in the middle of each month
        left_num = mdates.date2num(start_date)
        right_num = mdates.date2num(plot_right_date)
        ax_plan.set_xlim(left=left_num, right=right_num)
        ax_plan.xaxis.set_major_locator(mdates.MonthLocator(bymonthday=15))
        ax_plan.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
        fig.autofmt_xdate()

        # add bar caps between the two charts
        if surge:
            ylim = ax_plan.get_ylim()
            d = (ylim[1] - ylim[0]) * 0.05
            ylim = ax_surge.get_ylim()
            d2 = (ylim[1] - ylim[0]) * 0.10  # surge chart canvas height is 1/2 the plan chart canvas height
            for rect in gap_bars:
                x = rect.get_x()
                w = rect.get_width()
                h = rect.get_height()
                fc = rect.get_facecolor()
                if h >= surge_threshold:
                    # bottom cap
                    points = cap_points * [w/(2*np.pi), d] + [x, surge_threshold]
                    p = Polygon(points, closed=True, facecolor=fc, clip_on=False, aa=True, snap=True)
                    ax_plan.add_patch(p)
                    # top cap
                    points = cap_points_inv * [w/(2*np.pi), d2] + [x, surge_threshold]
                    p = Polygon(points, closed=True, facecolor=fc, clip_on=False, aa=True, snap=True)
                    ax_surge.add_patch(p)
                    ax_surge.vlines(x=[x, x+w-0.00001], ymin=surge_threshold - d2, ymax=surge_threshold, color='black',
                                    linewidth=0.8, clip_on=False, aa=True, snap=True)
            # add axes caps
            kwargs = dict(marker=r'$\sim$', markersize=10, color='black', markerfacecolor='black',
                          markeredgecolor='none', linestyle="none", clip_on=False)
            ax_plan.plot([0, 1], [1, 1], transform=ax_plan.transAxes, **kwargs)
            ax_surge.plot([0, 1], [0, 0], transform=ax_surge.transAxes, **kwargs)

        # Add horizontal lines for plan limit and upgrade/downgrade
        created_upgrade_labels = False
        created_downgrade_labels = False
        i = 0
        for plan in plan_over_time:
            plan_xmin = mdates.date2num(plan['start'])
            plan_xmax = mdates.date2num(plan['end'])
            traffic_limit = int(plan_info[plan['plan']]['traffic_limit'])
            upgrade_at = plan_info[plan['plan']]['upgrade_at']
            if traffic_limit is not None and upgrade_at is not None:
                # Limit and upgrade lines
                for ax in axs:
                    limit_text = {}
                    upgrade_text = {}
                    if not created_upgrade_labels:
                        limit_text['label'] = 'plan traffic limit (overages start)'
                        upgrade_text['label'] = 'upgrade to higher plan at ' + \
                                                f'{plan_info[plan_over_time[-1]["plan"]]['upgrade_at']:,}'
                        created_upgrade_labels = True
                    ax.hlines(y=traffic_limit, xmin=plan_xmin, xmax=plan_xmax, color='darkorange', gapcolor='w',
                              linestyle='dotted', linewidth=3, **limit_text)
                    ax.hlines(y=upgrade_at, xmin=plan_xmin, xmax=plan_xmax, color='r', gapcolor='w',
                              linestyle='dashed', linewidth=3, **upgrade_text)
            # Downgrade line
            downgrade_to = plan_info[plan['plan']]['downgrade_to']
            if downgrade_to is not None:
                for ax in axs:
                    downgrade_text = {}
                    ending_downgrade_to = plan_info[plan_over_time[-1]['plan']]['downgrade_to']
                    if not created_downgrade_labels and ending_downgrade_to is not None:
                        ending_downgrade_at = plan_info[ending_downgrade_to]['upgrade_at']
                        downgrade_text['label'] = 'downgrade to lower plan at ' + f'{ending_downgrade_at:,}'
                        created_downgrade_labels = True
                    downgrade_at = plan_info[downgrade_to]['upgrade_at']
                    ax.hlines(y=downgrade_at, xmin=plan_xmin, xmax=plan_xmax, color='g', gapcolor='w',
                              path_effects=[path_effects.Stroke(linewidth=4, foreground='white'), path_effects.Normal()],
                              linestyle='dashdot', linewidth=3, **downgrade_text)
            # Plan label
            text_height = matplotlib.rcParams['font.size'] * 1.25
            level = text_height * (i + 2)
            ax_top.annotate(plan['plan'], xy=(plan_xmin, ymax), xycoords='data', xytext=(2, 0 - level),
                        textcoords="offset points", weight="bold")
            # Plan label line calculations
            data_point = (plan_xmin, ymax)
            offset_points = (0, 2 * level + text_height/2)
            display_point = ax_top.transData.transform_point(data_point)  # Transform data coord to display (pixel) coord
            # Apply offset in pixels
            dpi = fig.dpi
            offset_in_inches = (offset_points[0] / dpi, offset_points[1] / dpi)
            offset_in_pixels = fig.dpi_scale_trans.transform_point(offset_in_inches)
            text_display_point = (display_point[0] + offset_in_pixels[0],
                                  display_point[1] - offset_in_pixels[1])  # Final display coordinate for the text
            text_data_point = ax_top.transData.inverted().transform_point(text_display_point)  # Transform to data coord
            text_data_y = text_data_point[1]
            # Draw the plan label line
            for ax in axs:
                ax.vlines(x=plan_xmin, ymin=traffic_limit, ymax=text_data_y, color='r', linestyle='dotted', gapcolor='w')

            i = 1 - i  # alternate plan label levels

        fig.legend(handlelength=3.0)

        ax_plan.set_xlabel('Month', fontsize='large')
        fig.supylabel('Pantheon Visitors')
        for ax in axs:
            ax.yaxis.set_major_formatter('{x:,.0f}')
        chart_title = f'{site["name"]} Pantheon Traffic'
        if main_fqdn:
            chart_title += f"\n{site_url}"
        ax_top.set_title(chart_title, loc='left')
        fig.text(0.90, 0.10, 'as of ' + end_date.strftime('%B %e, %Y'), ha='right', fontsize='small')

        #plt.show()
        buf = io.BytesIO()
        fig.savefig(buf, format='png')
        buf.seek(0)
        chart_image = buf.read()
        buf.close()
        plt.close(fig)

        # TODO: Create SVG chart

        sc.debug(f'[bold magenta]=== Creating the traffic table:')

        # TODO: for upgrade/downgrade and new plan columns, add an icon and a colored background so people can
        #   see at a glance if it's more or less than 50% of the time.

        # TODO: If Performance small and below Basic upgrade + no New Relic + No Solr + No Redis + mem usage low --> Switch to Basic

        # Load the overage protection data we need for this site and date range:
        # if sc.options.verbose > 1:
        #     results = db_session.query(PantheonOverageProtection).filter(
        #         PantheonOverageProtection.site_id == site['id'],
        #         PantheonOverageProtection.month.between(start_date, end_date)
        #     ).all()
        #     sc.debug('=== Overage protection data:')
        #     for r in results:
        #         sc.debug(r)
        #     sc.debug('-----')

        traffic_table_rows = {}
        d = (start_date.replace(day=1) - datetime.timedelta(days=15)).replace(day=1)
        op = db_session.get(PantheonOverageProtection, {"site_id": site['id'], "month": d})
        op_remaining = 0 if op is None else op.months_remaining
        site_plan_start = plan_over_time[0]['start'].replace(day=1)
        old_plan = None
        for month in visits_by_month.keys():
            ymd = datetime.date.fromisoformat(month + '-15')
            ymd1 = ymd.replace(day=1)
            if ymd < first_plan_day:
                ymd = first_plan_day
            if ymd > last_plan_day:
                ymd = last_plan_day
            if ymd1 < start_date:
                ymd1 = start_date
            if ymd1 > end_date:
                ymd1 = end_date.replace(day=1)
            if ymd1 < site_plan_start:
                continue
            d = ymd if ymd >= first_plan_day else first_plan_day
            plan = plan_on_day[d]
            if ymd1 == site_plan_start and plan != 'Basic':
                op_remaining = 4
            if old_plan in ('Sandbox', 'Basic') and plan not in ('Sandbox', 'Basic'):
                op_remaining = 4
            old_plan = plan
            traffic_table_rows[month] = {}
            traffic_table_rows[month]['month'] = datetime.datetime.strptime(month, '%Y-%m').strftime('%B %Y')
            traffic_table_rows[month]['visitors'] = f'{visits_by_month[month]:,.0f}'
            traffic_table_rows[month]['plan'] = plan
            traffic_limit = int(plan_info[plan]['traffic_limit'])
            traffic_table_rows[month]['plan-limit'] = f'{traffic_limit:,.0f}'
            traffic_table_rows[month]['upgrade-at'] = f'{plan_info[plan]['upgrade_at']:,.0f}'
            traffic_table_rows[month]['next-plan'] = plan_info[plan]['upgrade_to']
            downgrade_to = plan_info[plan]['downgrade_to']
            if downgrade_to is not None:
                downgrade_at = plan_info[downgrade_to]['upgrade_at']
                traffic_table_rows[month]['downgrade-at'] = f'{downgrade_at:,.0f}'
                traffic_table_rows[month]['previous-plan'] = downgrade_to
            else:
                traffic_table_rows[month]['downgrade-at'] = '-'
                traffic_table_rows[month]['previous-plan'] = '-'
            overage = max(visits_by_month[month] - traffic_limit, 0)
            overage_blocks = round((overage + overage_block_size / 2.0) / overage_block_size)
            overage_cost = overage_blocks * overage_block_cost
            overage_text = f'{overage:,.0f}'
            overage_blocks_text = f'{overage_blocks:,.0f}'
            overage_cost_text = f'${overage_cost:,.0f}'
            overage_protection_status = '-'
            # Overage protection started retroactively on 2024-01-01
            if month >= '2024-01' and plan != "Basic":
                overage_protection_status = ''
                if ymd.month == 1:
                    op_remaining = 4
                    overage_protection_status = 'Set to 4 months, '
                op_used = False
                if overage > 0 and op_remaining > 0:
                    op_remaining -= 1
                    op_used = True
                op = db_session.get(PantheonOverageProtection, {"site_id": site['id'], "month": ymd1})
                if op is None:
                    op = PantheonOverageProtection(
                        site_id=site['id'],
                        month=ymd1,
                        months_remaining=op_remaining,
                        used_this_month=op_used
                    )
                    db_session.add(op)
                else:
                    op.months_remaining = op_remaining
                    op.used_this_month = op_used
                if op_used:
                    overage_protection_status += f'used 1 month, '
                    overage_cost_text = '$0 (<span style="font-size:smaller;">waived ' + overage_cost_text + ')</span>'
                overage_protection_status += f'1 month remaining' if op_remaining == 1 \
                    else f'{op_remaining} months remaining'
            else:
                op_remaining = 0
                if plan != "Basic":
                    overage_text = '-'
                    overage_blocks_text = '-'
                    overage_cost_text = '-'
            traffic_table_rows[month]['overage'] = overage_text
            traffic_table_rows[month]['overage-blocks'] = overage_blocks_text
            traffic_table_rows[month]['overage-cost'] = overage_cost_text
            traffic_table_rows[month]['overage-protection'] = overage_protection_status

        db_session.commit()  # save the changes we made to the pantheon_overage_protection table

        sc.debug(traffic_table_rows)

        # Compare current plan cost to other plan costs

        median_visitors = 0
        cost_same = {}
        costs_median = {}
        cost_table_rows = {}
        estimate_start_date = end_date  # default both estimate start/end dates to the report end date
        estimate_end_date = end_date
        k = [d for d in visits_by_month.keys() if d >= site_plan_start.strftime('%Y-%m')]
        v = [visits_by_month[d] for d in k]
        months_until_recommendations = 0 if len(v) > 4 else 5 - len(v)
        if len(v) > 4:
            sc.debug('[bold magenta]=== Generating plan recommendations:')
            sc.debug('===== future costs for same traffic')
            for plan in plan_names:
                cost = float(plan_info[plan]['cost'])
                cost_by_month = []
                cost_for_plan_months = []
                op_remaining = 0
                for month in visits_by_month.keys():
                    visits = visits_by_month[month]
                    if month == end_date_yyyy_mm and estimate > 0:
                        visits = estimate
                    overage = max(visits - int(plan_info[plan]['traffic_limit']), 0)
                    overage_blocks = round((overage + overage_block_size / 2.0) / overage_block_size)
                    overage_cost = overage_blocks * overage_block_cost
                    if plan != 'Basic':
                        op = db_session.get(PantheonOverageProtection, {"site_id": site['id'],
                                                                     "month": datetime.date.fromisoformat(
                                                                         month + '-01')})
                        if op is not None:
                            if op.used_this_month:
                                overage_cost = 0
                        else:
                            if month.endswith('-01'):
                                op_remaining = 4
                            if overage > 0 and op_remaining > 0:
                                overage_cost = 0
                                op_remaining -= 1
                    cost += overage_cost
                    cost_by_month.append(overage_cost)
                    if month >= site_plan_start.strftime('%Y-%m'):
                        cost_for_plan_months.append(overage_cost)
                if len(cost_by_month) < 12:
                    cost += (12 - len(cost_by_month)) * np.median(cost_for_plan_months)
                cost_same[plan] = cost
                sc.debug(f'{plan}: ${cost:,.2f}')

            if estimate > 0:
                v[-1] = estimate
            median_visitors = np.median(v)
            sc.debug(f'Median Pantheon visitors per month: {median_visitors:,.0f}')
            sc.debug('===== future costs for median traffic')
            for plan in plan_names:
                overage = median_visitors - int(plan_info[plan]['traffic_limit'])
                if overage < 0:
                    overage = 0
                months_without_op = 12 if plan == 'Basic' else 8
                costs_median[plan] = float(plan_info[plan]['cost']) + \
                    round((overage + overage_block_size / 2.0) / overage_block_size) * \
                    overage_block_cost * months_without_op
                sc.debug(f'{plan}: ${costs_median[plan]:,.2f}')

            # find best costs
            # For each plan, we want to be conservative by picking the highest cost metric:
            costs_best = {p: max(cost_same[p], costs_median[p]) for p in plan_names}
            # find the key in costs_best with the lowest value:
            site_recommended_plan = min(costs_best, key=costs_best.get)

            if site['plan_name'] != site_recommended_plan:
                site_current_plan_index = plan_names.index(site['plan_name'])
                site_recommended_plan_index = plan_names.index(site_recommended_plan)
                savings = abs(cost_same[site['plan_name']] - costs_best[site_recommended_plan])
                extra_message = ''
                extra_text = ''
                if site_current_plan_index > site_recommended_plan_index:
                    if site_recommended_plan == 'Basic':
                        # Basic is a better deal, but only if the site owner isn't using Performance features
                        # other than Overage Protection.
                        # TODO: check to see if performance features are in use
                        #    New Relic, Solr, Redis, WP/Drupal Multisite
                        if site_current_plan == 'Performance Small':
                            site_recommended_plan = 'Performance Small'
                            savings = 0
                        # check to see if there is a plan between the current plan and Basic that also saves money
                        if site_current_plan_index > 1:  # not already Performance Small
                            sc.console.print(f'Checking for a better plan between {site_current_plan} and Basic')
                            bc = copy.copy(costs_best)
                            del bc['Basic']
                            alt = min(bc, key=bc.get)
                            sc.console.print(f'cheapest plan excluding Basic: {alt}')
                            if alt != site_current_plan:
                                sc.console.log(f'Found a better plan: {alt}')
                                extra_message = f'''
<p>Alternatively, you could switch the site to Pantheon's <strong>Basic</strong> plan for a savings of up to
<strong>${savings:,.2f}</strong>, if you do not need any of the Performance plan features.
If you want to switch to the <strong>Basic</strong> plan, please do so via the
<a href="https://admin.webservices.umich.edu/sites/{portal_site_id}/plan/">ITS Web Services Portal</a>
before June 30.</p>
'''
                                extra_text = f'''
Alternatively, you could switch the site to Pantheon's Basic plan for
a savings of up to ${savings:,.2f}, if you do not need any of the
Performance plan features. If you want to switch to the Basic plan,
please do so via the ITS Web Services Portal
<https://admin.webservices.umich.edu/sites/{portal_site_id}/plan/>
before June 30.
'''
                                savings = abs(cost_same[site['plan_name']] - costs_best[alt])
                                site_recommended_plan = alt
                            else:
                                site_recommended_plan = site_current_plan
                                savings = 0
                        # TODO: if Basic still looks best, give a special message recommending switching to Basic.
                    if site_recommended_plan != site_current_plan and end_of_contract_year:
                        its_downgrade_site = True
                        site_notices.append({
                            'type': 'alert',
                            'icon': '&#x1F6A8;',  # police car light
                            'csv': f'{site["name"]},its-will-change-plan,{site["plan_name"]},{site_recommended_plan},{savings:,.2f}',
                            'short': f'plan change to {site_recommended_plan} scheduled',
                            'message': f'''
<p>At 8 A.M. this Friday, June 28, ITS will move the <strong>{site["name"]}</strong> website from
Pantheon's <strong>{site["plan_name"]}</strong> plan to <strong>{site_recommended_plan}</strong>.</p>
<p>Based on the site's last 12 months of traffic, this may save you up to <strong>${savings:,.2f}</strong> over the
coming year.</p>
<p>You can move the site to a higher plan at any point in the year without penalty.  But if you prefer to have
<strong>{site["name"]}</strong> remain on <strong>{site["plan_name"]}</strong> &mdash; for
example, if you anticipate traffic will increase significantly over the next year &mdash; reply to this email
before 8 A.M. this Friday.</p>
{extra_message}
<p><i>You can only move a site to a lower plan between June 16 - 30 each year without incurring a substantial
financial penalty.</i></p>
    ''',
                            'text': f'''
At 8 A.M. this Friday, June 28, ITS will move the {site["name"]}
website from Pantheon's {site["plan_name"]} plan to
{site_recommended_plan}.

Based on the site's last 12 months of traffic, this may save you up to
${savings:,.2f} over the coming year.

You can move the site to a higher plan at any point in the year without
penalty.  But if you prefer to have {site["name"]} remain
on {site["plan_name"]} -- for example, if you anticipate
traffic will increase significantly over the next year -- reply to
this email before 8 A.M. this Friday.
{extra_text}
You can only move a site to a lower plan between June 16 - 30 each
year without incurring a substantial financial penalty.
'''
                        })
                        site_savings.append({'site': site['name'], 'savings': savings,
                                             'current_plan': site['plan_name'],
                                             'recommended_plan': site_recommended_plan})
                else:
                    site_notices.append({
                        'type': 'info',
                        'icon': '&#x1F50E;',  # magnifying glass
                        'csv': f'{site["name"]},its-recommends-plan,{site["plan_name"]},{site_recommended_plan},{savings:,.2f}',
                        'short': 'plan change recommended',
                        'message': f'''
<p><a href="https://admin.webservices.umich.edu/sites/{portal_site_id}/plan/">Moving <strong>{site["name"]}</strong>
to Pantheon's <strong>{site_recommended_plan}</strong> plan</a> may save you up to <strong>${savings:,.2f}</strong>
over the coming year if the site's traffic for the next 12 months is similar to the previous 12.</p>
<p>You may want to stay on the <strong>{site["plan_name"]}</strong> plan if the site has had one-time traffic spikes
or you think site traffic will be decreasing soon. Sites can move to higher plans any time, but can only be moved to
a lower plan between June 16 - 30 each year.</p>
''',
                        'text': f'''
Moving {site["name"]} to Pantheon's {site_recommended_plan} plan
<https://admin.webservices.umich.edu/sites/{portal_site_id}/plan/>
may save you up to ${savings:,.2f} over the coming year if the site's
traffic for the next 12 months is similar to the previous 12.

You may want to stay on the {site["plan_name"]} plan if the site
has had one-time traffic spikes or you think site traffic will be
decreasing soon. Sites can move to higher plans any time, but can only
be moved to a lower plan between June 16 - 30 each year.
'''
                    })
                    site_savings.append({'site': site['name'], 'savings': savings,
                                         'current_plan': site['plan_name'], 'recommended_plan': site_recommended_plan})

            sc.debug(f'Best plan for {site["name"]} is {site_recommended_plan} '
                     f'at ${costs_best[site_recommended_plan]:,.2f}')
            for plan in plan_names:
                cost_table_rows[plan] = {}
                cost_table_rows[plan]['plan'] = plan
                cost_table_rows[plan]['cost-same'] = f'${cost_same[plan]:,.2f}'
                cost_table_rows[plan]['cost-median'] = f'${costs_median[plan]:,.2f}'
                cost_table_rows[plan]['notes'] = ''
                if plan == site_recommended_plan:
                    cost_table_rows[plan]['notes'] = '<span class="pill pill-warning">Recommended Plan</span>'
                if plan == site['plan_name']:
                    if cost_table_rows[plan]['notes'] != '':
                        cost_table_rows[plan]['notes'] += ' &nbsp; '
                    cost_table_rows[plan]['notes'] += '<span class="pill pill-primary">Current Plan</span>'
                cost_table_rows[plan]['recommend'] = 'Yes' if plan == site_recommended_plan else 'No'

            estimate_start_date = (end_date.replace(day=1) + datetime.timedelta(days=32)).replace(day=1)
            estimate_end_date = estimate_start_date.replace(year=estimate_start_date.year + 1) - \
                datetime.timedelta(days=1)

        if wp_smell != '':
            site_notices.append({
                'type': 'info',
                'icon': '&#x1F50E;',  # magnifying glass
                'csv': f'{site["name"]},wp-smell,{json.dumps(wp_smell).replace(',', '\\,')}',
                'short': 'PHP code problems',
                'message': f'''
<p>The <code>wp</code> (WP CLI) command is reporting PHP code problems with <strong>{site["name"]}</strong>.
Even if this is not breaking anything at the moment, it should be fixed to avoid possible future problems:</p>
<pre>{html.escape(wp_smell)}</pre>
''',
            'text': f'''
The "wp" (WP CLI) command is reporting PHP code problems with
{site["name"]}. Even if this is not breaking anything at
the moment, it should be fixed to avoid possible future problems:

----- START WP CLI REPORTED PROBLEMS -----
{wp_smell}
----- END OF WP CLI REPORTED PROBLEMS -----

    ''',
            })

        if drush_smell != '':
            site_notices.append({
                'type': 'info',
                'icon': '&#x1F50E;',  # magnifying glass
                'csv': f'{site["name"]},drush-smell,{json.dumps(drush_smell).replace(',', '\\,')}',
                'short': 'PHP code problems',
                'message': f'''
<p>The <code>drush</code> command is reporting PHP code problems with <strong>{site["name"]}</strong>. Even
if this is not breaking anything at the moment, it should be fixed to avoid possible future problems:</p>
<pre>{html.escape(drush_smell)}</pre>
''',
                'text': f'''
The "drush" command is reporting PHP code problems with
{site["name"]}. Even if this is not breaking anything
at the moment, it should be fixed to avoid possible future problems:

----- START DRUSH REPORTED PROBLEMS -----
{drush_smell}
----- END OF DRUSH REPORTED PROBLEMS -----

''',
            })

            if composer_smell != '':
                site_notices.append({
                    'type': 'info',
                    'icon': '&#x1F50E;',  # magnifying glass
                    'csv': f'{site["name"]},composer-smell,{json.dumps(composer_smell).replace(',', '\\,')}',
                    'short': 'PHP code problems',
                    'message': f'''
        <p>The <code>composer</code> command is reporting PHP code problems with <strong>{site["name"]}</strong>. Even
        if this is not breaking anything at the moment, it should be fixed to avoid possible future problems:</p>
        <pre>{html.escape(drush_smell)}</pre>
        ''',
                    'text': f'''
        The "composer" command is reporting PHP code problems with
        {site["name"]}. Even if this is not breaking anything
        at the moment, it should be fixed to avoid possible future problems:

        ----- START COMPOSER REPORTED PROBLEMS -----
        {composer_smell}
        ----- END OF COMPOSER REPORTED PROBLEMS -----

        ''',
                })

        sc.debug('===== Notices:\n', site_notices)
        sc.debug('===== Sections:\n', site_context['sections'])

        if 'UMich' in sc.config and 'enabled' in sc.config['UMich'] and sc.config['UMich']['enabled']:
            r = sc.config['UMich']['portal']['sites'][site['name']]['owner_group']
            r = r.replace(' ', '.')
            recipients = f'{r}@umich.edu, {r}-owners@umich.edu'
            contacts = f'{r}@umich.edu'
        else:
            site_team = terminus('site:team:list', site_id)
            recipients = ', '.join([site_team[team_member]['email'] for team_member in site_team])
            contacts = contacts.replace(',', '')

        # Create email from template
        sorted_notices = [n for n in site_notices if n['type'] == 'alert'] + \
                         [n for n in site_notices if n['type'] == 'warning'] + \
                         [n for n in site_notices if n['type'] == 'info']
        report = f'Pantheon Traffic Report, {end_date.strftime('%b %e, %Y')}'
        subject = f'{site["name"]}: {report}'
        if its_downgrade_site:
            subject = f'Time Sensitive: {site["name"]}: plan change | {report}'
        elif len(sorted_notices) > 0:
            if sorted_notices[0]['type'] == 'alert':
                subject = f'Action Required: {site["name"]}: {sorted_notices[0]['short']} | {report}'
            elif sorted_notices[0]['type'] == 'warning':
                subject = f'Action Recommended: {site["name"]}: {sorted_notices[0]['short']} | {report}'
            # no subject prefix for info notices

        banner_cid = make_msgid(domain='webservices.umich.edu')
        chart_cid = make_msgid(domain='webservices.umich.edu')

        template_dict = dict(
            dry_run_recipient='' if sc.options.for_real else recipients,
            subject=subject,
            site_name=site["name"],
            site_url=site_url,
            portal_site_id=portal_site_id,
            current_plan=site_current_plan,
            recommended_plan=site_recommended_plan,
            current_plan_index=site_current_plan_index,
            recommended_plan_index=site_recommended_plan_index,
            traffic_table_columns=traffic_table_columns,
            traffic_table_rows=traffic_table_rows,
            cost_table_columns=cost_table_columns,
            cost_table_rows=cost_table_rows,
            traffic_date=end_date.strftime('%B %e, %Y'),
            current_month_estimate=f'Estimate for Pantheon visitors at the end of {end_date.strftime("%B %Y")}: '
                                   f'{estimate:,.0f}' if estimate >= 0 else '',
            median_monthly_visitors=f'{median_visitors:,.0f}',
            months_until_recommendations=months_until_recommendations,
            estimate_start_date=estimate_start_date.strftime('%B %e, %Y'),
            estimate_end_date=estimate_end_date.strftime('%B %e, %Y'),
            notices=sorted_notices,
            news=sc.news,
            sections=site_context['sections'],
            end_of_contract_year=end_of_contract_year,
            banner_cid=banner_cid[1:-1],
            chart_cid=chart_cid[1:-1],
        )

        with open('email_template.html', 'r', encoding='utf-8') as f:
            html_template = Template(f.read())
        html_body = html_template.render(**template_dict)
        # Write the results to a file for debugging.  Later, we'll use this file as input to the PHP script that
        # inlines the CSS. We're not piping the data to/from the script directly because the files are useful
        # for inspecting/debugging.
        with open(f'build/{site["name"]}.html', 'w', encoding='utf-8') as f:
            f.write(html_body)

        with open('email_template.txt', 'r', encoding='utf-8') as f:
            text_template = Template(f.read())
        text_body = text_template.render(**template_dict)
        with open(f'build/{site["name"]}.txt', 'w', encoding='utf-8') as f:
            f.write(text_body)

        subprocess.run(['php', 'inline-styles.php', f'build/{site["name"]}.html', f'build/{site["name"]}-inline.html'],
                       stdout=sys.stdout, stderr=sys.stderr, check=True)
        with open(f'build/{site["name"]}-inline.html', 'r', encoding='utf-8') as f:
            html_body = f.read()

        style_elements = re.findall(r'(<style.*?</style>)', html_body, re.DOTALL)
        for style in style_elements:
            # Add !important to the end of each CSS attribute that doesn't already end with !important
            modified_style = re.sub(r'(?<!important);', ' !important;', style, flags=re.DOTALL)
            html_body = html_body.replace(style, modified_style)

        with open(f'build/{site["name"]}-inline2.html', 'w', encoding='utf-8') as f:
            f.write(html_body)

        msg = EmailMessage()
        msg['From'] = 'University of Michigan Webmaster Team <webmaster@umich.edu>'
        if sc.options.for_real:
            msg['To'] = recipients
            msg['Bcc'] = 'januside@go.mail.umich.edu, its-webmaster@go.mail.umich.edu'
        else:
            msg['To'] = f'januside@go.mail.umich.edu, {sc.options.smtp_username}@umich.edu'
        msg['Reply-to'] = 'webmaster@umich.edu'
        msg['Date'] = datetime.datetime.now(datetime.UTC).strftime("%a, %d %b %Y %T %z")
        msg['Subject'] = subject

        msg.set_content(text_body, subtype='plain', charset='utf-8')
        msg.add_alternative(html_body, subtype='html', charset='utf-8')

        msg.get_payload()[1].add_related(
            wordmark_image,
            maintype='image',
            subtype='png',
            filename='pantheon-traffic-email-banner.png',
            cid=banner_cid,
            disposition='inline',
        )

        msg.get_payload()[1].add_related(
            chart_image,
            maintype='image',
            subtype='png',
            filename=f'pantheon-traffic_{site["name"]}_{end_date.strftime("%Y%m%d")}.png',
            cid=chart_cid,
            disposition='inline',
        )

        for attachment in site_context['attachments']:
            msg.get_payload()[1].add_related(
                attachment['data'],
                maintype=attachment['maintype'],
                subtype=attachment['subtype'],
                filename=attachment['filename'],
                cid=attachment['cid'],
                disposition=attachment['disposition'],
            )

        with open(f'build/{site["name"]}.eml', 'wb') as f:
            f.write(msg.as_bytes(policy=SMTP))

        smtp_connection.send_message(msg)
        emails_sent += 1
        # TODO: add feature to send mails using SendGrid.
        # This script can run longer than some SMTP servers will allow a connection to be open.
        if (emails_sent % 20) == 0:
            if sc.options.verbose:
                sc.debug(f'[bold yellow]{emails_sent} emails sent, closing and reopening the SMTP connection.')
            smtp_connection.quit()
            time.sleep(3)
            smtp_connection = smtp_login()

        for n in site_notices:
            fields = n['csv'].split(',')
            fields.insert(1, contacts)
            all_warnings.append(','.join(fields))

        plt.close(fig)  # needed to free up memory when sc.options.all_sites is True

        # TODO: % Pages Cached -- should be Cloudflare
        # TODO: CSV attachment

    db_session.close()
    db_engine.dispose()
    smtp_connection.quit()

    if sc.options.all:
        sc.console.print(f'\n[bold green]Email sent for {emails_sent} of {site_count} sites.\n')
        ymd = datetime.datetime.today().strftime('%Y%m%d')
        with open(f'{ymd}-notices.csv', 'w', encoding='utf-8') as f:
            for n in all_warnings:
                f.write(n + '\n')

        with open(f'{ymd}-results.json', 'w', encoding='utf-8') as f:
            json.dump(site_results, f, indent=4)
    else:
        for n in all_warnings:
            sc.console.print(n)
        pprint(site_results)

    sc.console.print(f'\n[bold green]Site savings:\n')
    pprint(site_savings)
    sc.console.print(f'Sites with savings: {len(site_savings)}')
    sc.console.print(f'Total savings: ${sum([s["savings"] for s in site_savings]):,.2f}')

    sc.debug('Done!')


if __name__ == '__main__':
    main()
